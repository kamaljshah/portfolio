<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="https://kit.fontawesome.com/c1095fcd87.js" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="css/main.css">
    
    <title>Kamal Shah SUMARIA</title>
</head>

<body>
    <header>
    </header>

    <main id="work">      
        <h1 class="lg-heading-WebGL_Basics">
            <span class="text-secondary">SUMARIA SYSTEMS</span>
        </h1>

        <div class="webgl_basics">
            <h3 class="text-secondary">DANVERS, MA , U.S.A (07/1999 - 06/2008)</h3>
            <a href="https://www.sumariasystems.com/">Link to SUMARIA SYSTEMS</a><br/>
            <p> Tracktool :  I have assumed many roles at Sumaria Systems from junior programmer to senior positions and also ISO Rep for the company.<br/>
            I designed and developed an Automatic Surveyor software for the AdCam package using <b class="glow">Visual C#.NEt</b> on <b class="glow">Win2000</b>. GPS data is received  asynchronously via <b class="glow">GPS</b> controller board. This multi-threaded application manages asynchronous read operations on a separate thread and user input on the main thread. The software seamlessly integrated with the main component thus avoiding use of third party software. Time for survey could be preset saving ample time for concentrating on other duties. <br/>
            Designed and developed tools to compute the Altitude, Zone and Track of a racetrack. The main component of the tool was to create a digital track of an existing racetrack in virtual space. My role was to capture data from a GPS data file in GPGGA format and export it to <b class="glow">Microsoft Visio</b>. XSL transformation were done using <b class="glow">MSXML parser</b> The tool created an XML document from the VISIO file which is used by the Graphics package that was developed to show real time display of race cars. A sorting algorithm was written to remove all zombie data points which interfered with the smooth display of track in Real Time Graphics Display. A separate algorithm was developed to calculate the cross-sectional altitude of the track. This algorithm helped to display the track in a 3D mode on a 2D layer. The algorithm implements an algorithm similar to Bresenham's line algorithm for extrapolating the next point in a line.<br/>
            </p>
            <p> Controller: My role was to design a Controller to simulate the graphical representation of GPS data. The software was written in <b class="glow">VC++ 6.0</b>. A CDC member function was used to represent the moving car as a circular shape. The objecs of  CRect, CRgn, CBrush which were instantiated and passed to the CDC object. The simulated car was written to analyze the PAN, Tilt, and Zoom functions. This module helped in analyzing the different angles and functions of the camera thus saving the burden of lugging heavy camera equipment. <br/>
            </p>
            <p> After developing the modules of the AdCam software. A demo was created to showcase the project to different businesses. My role was to create the demo. This was done using <b class="glow">Demoshiled 7.5</b><br/>
            </p>
            <p> ISO 9001: 2000 certification. My role as a management representative and data analyst was to understand the ISO 9001:2000 standards and create a database concurrently to manage the Quality Management System processes. To represent the company during Audits and help the Auditors with QMS processes. Resolve issues and take actions regarding customer complaints.
            I also helped in the ISO 9001:2000 certification of S4 Inc for one of its IT Governemtn proposals. I strategically planned all processes and got them certified in less than 2 months. <br/>
            </p>
            <p> Development of a GUI system:
               Clients using the legacy COBOL system wanted a Graphical User Interface (GUI) for their application. SP11 a graphical conversion tool was used to create a windows look and feel maintaining all the underlying functionality of COBOL.  <br/>
            </p>

            <h2 class="sm-heading">Sample Code for Track tool :</h2>

            <div class="bio">
                <h3 class="text-secondary">Sample C++ code for TrackTool </h3>
                <div class="OISCSFileSection">
                    <pre class="csharpcode">
<span class="rem">// TrackToolDlg.cpp : implementation file</span>
<span class="rem">//</span>

#include <span class="str">"stdafx.h"</span>
#include <span class="str">"TrackTool.h"</span>
#include <span class="str">"TrackToolDlg.h"</span>

#ifdef _DEBUG
<span class="preproc">#define</span> <span class="kwrd">new</span> DEBUG_NEW
<span class="preproc">#endif</span>


<span class="rem">// CAboutDlg dialog used for App About</span>

<span class="kwrd">class</span> CAboutDlg : <span class="kwrd">public</span> CDialog
{
<span class="kwrd">public</span>:
    CAboutDlg();

<span class="rem">// Dialog Data</span>
    <span class="kwrd">enum</span> { IDD = IDD_ABOUTBOX };

    <span class="kwrd">protected</span>:
    <span class="kwrd">virtual</span> <span class="kwrd">void</span> DoDataExchange(CDataExchange* pDX);    <span class="rem">// DDX/DDV support</span>

<span class="rem">// Implementation</span>
<span class="kwrd">protected</span>:
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
}

<span class="kwrd">void</span> CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
END_MESSAGE_MAP()


<span class="rem">// CTrackToolDlg dialog</span>



CTrackToolDlg::CTrackToolDlg(CWnd* pParent <span class="rem">/*=NULL*/</span>)
    : CDialog(CTrackToolDlg::IDD, pParent),
    theMap(0),theVisio(0),
    totalWidth(796),totalHeight(468), <span class="rem">//468</span>
    myCarId(-999),
    index(0),
    m_saveVisioFile(FALSE),
    m_visXOrigin(0),m_visYOrigin(0),
    dwBufLen(255),
    progCtrl(0),
    lenOfMsg(0),ch(0),
    m_altitude(0)
    
{
    m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);
    m_hcurArrow = AfxGetApp()-&gt;LoadStandardCursor(IDC_ARROW);
    m_hcurWait = AfxGetApp()-&gt;LoadStandardCursor(IDC_WAIT);
}

<span class="kwrd">void</span> CTrackToolDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    DDX_Control(pDX, IDC_CANCEL_SOURCE_FILE, m_cancelDataInput);
    DDX_Control(pDX, IDC_VEHICLE_ID, m_vehicleId);
    DDX_Control(pDX, IDC_CREATE_XML, m_createXML);
    DDX_Control(pDX, IDC_STATUS, m_status);
    DDX_Control(pDX, IDC_EDIT1, m_inputFile);
    DDX_Control(pDX, IDC_EDIT2, m_outputFile);
    DDX_Control(pDX, IDC_APPEND, m_appendFile);
    DDX_Control(pDX, IDC_TRACK_PROGRESS, m_trackProgress);
}

BEGIN_MESSAGE_MAP(CTrackToolDlg, CDialog)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    <span class="rem">//}}AFX_MSG_MAP</span>
    ON_BN_CLICKED(IDC_DATA_SOURCE_FILE, OnBnClickedDataSourceFile)
    ON_BN_CLICKED(IDC_CANCEL_SOURCE_FILE, OnBnClickedCancelSourceFile)
    ON_CBN_SELCHANGE(IDC_VEHICLE_ID, OnCbnSelchangeVehicleId)
    ON_WM_TIMER()
    ON_BN_CLICKED(IDC_CREATE_XML, OnBnClickedCreateXml)
    ON_BN_CLICKED(IDC_START, OnBnClickedStart)
    ON_BN_CLICKED(IDC_APPEND, OnBnClickedAppend)
END_MESSAGE_MAP()


<span class="rem">// CTrackToolDlg message handlers</span>

BOOL CTrackToolDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    <span class="rem">//ShowWindow(SW_SHOWMAXIMIZED);    //$$ This function helps maximize the window to full screen</span>

    <span class="kwrd">if</span>(theMap != NULL)
        delete theMap;    <span class="rem">// delete MapDisplay object and create new</span>
    theMap = <span class="kwrd">new</span> CMapDisplay(theGlobalObserver);

    
    CRect windowClientRect;
    GetClientRect(windowClientRect);
    totalHeight = windowClientRect.Height() - 111;
    totalWidth = windowClientRect.Width() - 4;
    <span class="rem">/*</span>
<span class="rem">    if (theMap-&gt;Create(NULL,WS_CHILD | WS_VISIBLE , CRect(0,0,totalWidth + 4,totalHeight + 2), this) == FALSE) {</span>
<span class="rem">        MessageBox("Creation failed ");</span>
<span class="rem">    }</span>
<span class="rem">    theMap-&gt;SetWindowPos(NULL, 2, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);</span>
<span class="rem">    */</span>
    m_trackProgress.SetPos(0);
    
    m_cancelDataInput.EnableWindow(FALSE);
    m_appendFile.EnableWindow(FALSE);
    GetDlgItem(IDC_START)-&gt;EnableWindow(FALSE);
    <span class="rem">// Add "About..." menu item to system menu.</span>

    <span class="rem">// IDM_ABOUTBOX must be in the system command range.</span>
    ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX);
    ASSERT(IDM_ABOUTBOX &lt; 0xF000);

    CMenu* pSysMenu = GetSystemMenu(FALSE);
    <span class="kwrd">if</span> (pSysMenu != NULL)
    {
        CString strAboutMenu;
        strAboutMenu.LoadString(IDS_ABOUTBOX);
        <span class="kwrd">if</span> (!strAboutMenu.IsEmpty())
        {
            pSysMenu-&gt;AppendMenu(MF_SEPARATOR);
            pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
        }
    }

    <span class="rem">// Set the icon for this dialog.  The framework does this automatically</span>
    <span class="rem">//  when the application's main window is not a dialog</span>
    SetIcon(m_hIcon, TRUE);            <span class="rem">// Set big icon</span>
    SetIcon(m_hIcon, FALSE);        <span class="rem">// Set small icon</span>

    <span class="rem">// TODO: Add extra initialization here</span>
    
    <span class="kwrd">return</span> TRUE;  <span class="rem">// return TRUE  unless you set the focus to a control</span>
}

<span class="kwrd">void</span> CTrackToolDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
    <span class="kwrd">if</span> ((nID &amp; 0xFFF0) == IDM_ABOUTBOX)
    {
        CAboutDlg dlgAbout;
        dlgAbout.DoModal();
    }
    <span class="kwrd">else</span>
    {
        CDialog::OnSysCommand(nID, lParam);
    }
}

<span class="rem">// If you add a minimize button to your dialog, you will need the code below</span>
<span class="rem">//  to draw the icon.  For MFC applications using the document/view model,</span>
<span class="rem">//  this is automatically done for you by the framework.</span>

<span class="kwrd">void</span> CTrackToolDlg::OnPaint() 
{
    <span class="kwrd">if</span> (IsIconic())
    {
        CPaintDC dc(<span class="kwrd">this</span>); <span class="rem">// device context for painting</span>

        SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0);

        <span class="rem">// Center icon in client rectangle</span>
        <span class="kwrd">int</span> cxIcon = GetSystemMetrics(SM_CXICON);
        <span class="kwrd">int</span> cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&amp;rect);
        <span class="kwrd">int</span> x = (rect.Width() - cxIcon + 1) / 2;
        <span class="kwrd">int</span> y = (rect.Height() - cyIcon + 1) / 2;

        <span class="rem">// Draw the icon</span>
        dc.DrawIcon(x, y, m_hIcon);
    }
    <span class="kwrd">else</span>
    {
        CDialog::OnPaint();
    }
}

<span class="rem">// The system calls this function to obtain the cursor to display while the user drags</span>
<span class="rem">//  the minimized window.</span>
HCURSOR CTrackToolDlg::OnQueryDragIcon()
{
    <span class="kwrd">return</span> static_cast&lt;HCURSOR&gt;(m_hIcon);
}

<span class="kwrd">void</span> CTrackToolDlg::OnBnClickedDataSourceFile()
{
    <span class="rem">// TODO: Add your control notification handler code here</span>
    m_DataFile = FALSE;    <span class="rem">// initialized to false will later be set depending on the file chosen</span>

    m_inputFile.SetWindowText(NULL);
    m_outputFile.SetWindowText(NULL);
    m_createXML.EnableWindow(FALSE);
    CString fileExtension,datFile;

    CFileDialog openDialog(TRUE, <span class="str">".*"</span>);
    openDialog.m_ofn.lpstrInitialDir = <span class="str">""</span>;
    openDialog.m_ofn.lpstrFilter = <span class="str">"All Files\0*.*\0\0"</span>;

    <span class="rem">// Return value when the File dialog box opens</span>
    INT_PTR nRet = -1;
    nRet = openDialog.DoModal();

    
    

    <span class="rem">// Handle the return value from DoModal</span>
    <span class="kwrd">switch</span> ( nRet )
    {
    <span class="kwrd">case</span> -1: 
        em.MessageBox(<span class="str">"Dialog Box could not be created !"</span>,<span class="str">""</span>,MB_OK);
        <span class="kwrd">break</span>;
    <span class="kwrd">case</span> IDABORT:
      <span class="rem">// Do something</span>
        em.MessageBox(<span class="str">"problem opening file, cause:"</span>, <span class="str">"file may not exist\n Close and Retry"</span>, MB_OK);
        exit(0);
        
        <span class="kwrd">break</span>;
    <span class="kwrd">case</span> IDOK:
        <span class="rem">// Do something</span>
        GetDlgItem(IDC_DATA_SOURCE_FILE)-&gt;EnableWindow(FALSE);
        m_cancelDataInput.EnableWindow(TRUE);
        datFile = <span class="str">"dat"</span>;
        <span class="kwrd">if</span>((input = fopen(openDialog.GetPathName(), <span class="str">"rb"</span>)) != NULL)
        {
            fileExtension = openDialog.GetFileExt();    <span class="rem">// returns the file extension</span>
            fileExtension.MakeLower();

            <span class="kwrd">if</span>(datFile.Find(fileExtension) == -1)
            <span class="rem">//if(fileExtension == "txt")</span>
            {
                <span class="rem">// it is either a txt file or someother file</span>
                m_DataFile = FALSE;
                OnReadCarData(m_DataFile);
                rewind(input);
                <span class="kwrd">break</span>;
            }
            <span class="kwrd">else</span>
            <span class="rem">//if(fileExtension == "dat")</span>
            {
                m_DataFile = TRUE;
                OnReadCarData(m_DataFile);
                rewind(input);
                <span class="kwrd">break</span>;
            }    
        }
       <span class="kwrd">else</span>
           em.MessageBox(<span class="str">"problem opening file, cause:"</span>, <span class="str">"file may not exist"</span>, MB_OK);
      <span class="kwrd">break</span>;
   <span class="kwrd">case</span> IDCANCEL:
      <span class="rem">// Do something</span>
       m_inputFile.SetWindowText(NULL);
       <span class="rem">//m_cancelDataInput.EnableWindow(TRUE);</span>
       m_createXML.EnableWindow(TRUE);
       
      <span class="kwrd">break</span>;
   <span class="kwrd">default</span>:
      <span class="rem">// do something</span>
      <span class="kwrd">break</span>;
   };                
}

<span class="kwrd">void</span> CTrackToolDlg::OnBnClickedCancelSourceFile()
{
    <span class="rem">// TODO: Add your control notification handler code here</span>

    <span class="rem">// save the output file</span>
    m_outputFile.GetWindowText(status);    <span class="rem">// get the file name</span>
    vName.SetString(status);
    <span class="kwrd">if</span>(m_saveVisioFile != FALSE)
        theVisio-&gt;DOMDocumentPtr-&gt;save(vName);
    m_saveVisioFile = FALSE;
<span class="rem">/*</span>
<span class="rem">    // clear the visio lists</span>
<span class="rem">    if(!theVisio-&gt;xmlInValuesList.empty())</span>
<span class="rem">    theVisio-&gt;xmlInValuesList.clear();</span>
<span class="rem"></span>
<span class="rem">    if(!theVisio-&gt;xmlOutValuesList.empty())</span>
<span class="rem">    theVisio-&gt;xmlOutValuesList.clear();</span>
<span class="rem"></span>
<span class="rem">    if(!theVisio-&gt;xmlPitInValuesList.empty())</span>
<span class="rem">    theVisio-&gt;xmlPitInValuesList.clear();</span>
<span class="rem"></span>
<span class="rem">    if(!theVisio-&gt;xmlShapeList.empty())</span>
<span class="rem">    theVisio-&gt;xmlShapeList.clear();</span>
<span class="rem"></span>
<span class="rem">    if(!theVisio-&gt;xmlStartStopList.empty())</span>
<span class="rem">    theVisio-&gt;xmlStartStopList.clear();</span>
<span class="rem"></span>
<span class="rem">    if(!theVisio-&gt;xmlTrackList.empty())</span>
<span class="rem">    theVisio-&gt;xmlTrackList.clear();</span>
<span class="rem"></span>
<span class="rem">    if(!theVisio-&gt;xmlTurnValuesList.empty())</span>
<span class="rem">    theVisio-&gt;xmlTurnValuesList.clear();</span>
<span class="rem"></span>
<span class="rem">    // clear dlg list</span>
<span class="rem">    if(!trackDataList.empty())</span>
<span class="rem">    trackDataList.clear();</span>
<span class="rem">*/</span>
    <span class="rem">// Enable User to create XML</span>
    m_createXML.EnableWindow(TRUE);
    
    <span class="rem">// incase file is opened close it</span>
    <span class="kwrd">if</span>(input != NULL)
        fclose(input);    <span class="rem">// close the file incase it is opened.</span>
    <span class="rem">//em.MessageBox("problem closing file, cause:", "file may not exist\n Close and Retry", MB_OK);</span>

    <span class="rem">// incase timer is on Kill it</span>
    KillTimer(1234);

    index = 0;
    <span class="rem">// set the frameNumber to 0 &amp; RedrawWindow</span>
    theMap-&gt;frameNumber = 0;
    theMap-&gt;easting = 0;
    theMap-&gt;northing = 0;
    <span class="rem">//RedrawWindow(NULL,NULL,RDW_INVALIDATE);</span>

    <span class="rem">// reset the Combo box</span>
    m_vehicleId.ResetContent();

    <span class="rem">// uninitialize the COM Interface</span>
    <span class="rem">// the COM Interface is ReferenceCounted and hence there is no need to release it</span>

    <span class="rem">// set the Progress Indicator to zero</span>
    progCtrl = 0;
    m_trackProgress.SetPos(progCtrl);
    
    <span class="rem">// Enable Select file button and disable Cancel File button</span>
    GetDlgItem(IDC_DATA_SOURCE_FILE)-&gt;EnableWindow(TRUE);
    GetDlgItem(IDC_START)-&gt;EnableWindow(FALSE);
    GetDlgItem(IDC_APPEND)-&gt;EnableWindow(FALSE);
    m_cancelDataInput.EnableWindow(FALSE);
    
    <span class="rem">//m_createXML.EnableWindow(FALSE);</span>
    
    
    
}

<span class="rem">// the logic to read the car number into the combo box is </span>
<span class="rem">// included in this part</span>
<span class="kwrd">void</span> CTrackToolDlg::OnReadCarData(BOOL m_DataFile)
{
    Position p;
    BOOL fileType = m_DataFile;

    <span class="kwrd">if</span>(!trackDataList.empty())
        trackDataList.clear();
    <span class="kwrd">if</span>(fileType == TRUE)    <span class="rem">// if dat file</span>
    {
        <span class="kwrd">while</span>(!feof(input))
        {
            p.readData(input);
            temp.CarId = p.getCarID();
            temp.Easting = p.getEasting();
            temp.Northing = p.getNorthing();
            temp.Altitude = p.getAltitude();

            trackDataList.push_back(temp);
        }

    }    
    <span class="kwrd">else</span>                    <span class="rem">// if txt file or any selected file</span>
    {
        <span class="kwrd">char</span> bufferCMC[50];    <span class="rem">// buffer to hold CMC string</span>
        <span class="kwrd">char</span> bufferAshTech[52];    <span class="rem">// buffer to hold ASHTECH string</span>

        lenOfMsg = 0;
        <span class="kwrd">while</span>(!feof(input))
        {
            ch = getc(input);
            
            <span class="kwrd">if</span>((<span class="kwrd">char</span>)ch == <span class="str">'\n'</span>)
            {
                
                <span class="kwrd">if</span>(lenOfMsg == 50)
                {
                    
                    
                    <span class="rem">// CMC board</span>
                    
                    <span class="kwrd">char</span> inputChar = <span class="str">'\0'</span>;
                    
                    <span class="rem">//bufferCMC[0] = inputChar;</span>
                    bufferCMC[49] = <span class="str">'\0'</span>;
                    <span class="kwrd">if</span> (isValidMessage(bufferCMC)) {
            
                        
                        Position p(bufferCMC);
                        theGlobalObserver.Notify(p);    
                        temp.CarId = p.getCarID();
                        temp.Easting = p.getEasting();
                        temp.Northing = p.getNorthing();
                        temp.Altitude = p.getAltitude();
                        trackDataList.push_back(temp);
                    }    <span class="rem">// end if (isValidMessage(messageBuffer))</span>
        
                    
                }    <span class="rem">// enf if(lenOfMsg == 50)</span>
                <span class="kwrd">if</span>(lenOfMsg == 52)
                {
                    
                    <span class="rem">// Ashtech board</span>
                    <span class="kwrd">char</span> inputChar = <span class="str">'\0'</span>;
                    
                    <span class="rem">//bufferAshTech[0] = inputChar;</span>
                    bufferAshTech[51] = <span class="str">'\0'</span>;
                    <span class="kwrd">if</span> (isValidNewMessage(bufferAshTech)) {
            
                        
                        NewPosition newp(bufferAshTech);
                        theGlobalObserver.Notify(newp);    
                        temp.CarId = newp.getCarID();
                        temp.Easting = newp.getEasting();
                        temp.Northing = newp.getNorthing();
                        temp.Altitude = newp.getAltitude();
                        trackDataList.push_back(temp);
                    }    <span class="rem">// end if (isValidMessage(messageBuffer))</span>
        
                }    <span class="rem">// end if(lenOfMsg == 52)</span>
                lenOfMsg = 0;
            }    <span class="rem">// end if(((char)ch) == '$')</span>
            <span class="kwrd">else</span>
            {
                
                <span class="kwrd">if</span>(lenOfMsg &lt;= 49)
                    bufferCMC[lenOfMsg] = <span class="kwrd">char</span>(ch);
                
                <span class="kwrd">if</span>(lenOfMsg &lt;= 51)
                    bufferAshTech[lenOfMsg] = <span class="kwrd">char</span>(ch);
                ++lenOfMsg;
            }
        }    <span class="rem">// end while(!feof(input))</span>
        lenOfMsg = 0;    <span class="rem">// set the length again to 0 </span>
        <span class="rem">/*</span>
<span class="rem">        bool linesProcessed = false;</span>
<span class="rem">        char messageBuffer[50];</span>
<span class="rem"></span>
<span class="rem">        while ((!feof(input)) &amp;&amp; (!linesProcessed) ) {</span>
<span class="rem">            char inputChar = '\0';</span>
<span class="rem">        </span>
<span class="rem">            while ((inputChar != '$') &amp;&amp; (!feof(input)))</span>
<span class="rem">                fread(&amp;inputChar, 1, 1, input);</span>
<span class="rem"></span>
<span class="rem">            messageBuffer[0] = inputChar;</span>
<span class="rem">            fread(&amp;messageBuffer[1], 48, 1, input);</span>
<span class="rem">            messageBuffer[49] = '\0';</span>
<span class="rem">        </span>
<span class="rem"></span>
<span class="rem">            if (isValidMessage(messageBuffer)) {</span>
<span class="rem">            </span>
<span class="rem">                Position p(messageBuffer);</span>
<span class="rem">                theGlobalObserver.Notify(p);    </span>
<span class="rem">                temp.CarId = p.getCarID();</span>
<span class="rem">                temp.Easting = p.getEasting();</span>
<span class="rem">                temp.Northing = p.getNorthing();</span>
<span class="rem">                temp.Altitude = p.getAltitude();</span>
<span class="rem"></span>
<span class="rem">                trackDataList.push_back(temp);</span>
<span class="rem"></span>
<span class="rem">            </span>
<span class="rem">            }    // end if (isValidMessage(messageBuffer))</span>
<span class="rem">        }    // end while ((!feof(input)) &amp;&amp; (!linesProcessed) )</span>
<span class="rem"></span>
<span class="rem">        */</span>
    }    <span class="rem">// end else</span>

    

    <span class="rem">// fill the combo box with carNumber from the trackDataList</span>
    <span class="rem">// check to see if list not empty first;</span>

    <span class="kwrd">char</span> buffer[256];
    
    <span class="kwrd">if</span>(trackDataList.size() &gt; 0)    <span class="rem">// some data is available</span>
    {
        m_vehicleId.ResetContent();
        
        <span class="kwrd">for</span>(trackDataListIterator = trackDataList.begin();
            trackDataListIterator != trackDataList.end();
            trackDataListIterator++)
        {
            temp = *trackDataListIterator;
            sprintf(buffer,<span class="str">"%1d"</span>,temp.CarId);
            <span class="kwrd">int</span> nIndex = m_vehicleId.FindString(-1,buffer);
            <span class="kwrd">if</span>(nIndex == CB_ERR)
                m_vehicleId.AddString(buffer);
        }    <span class="rem">// end for loop    </span>
        MessageBox(<span class="str">"Please Select a Car Number from the Combo box"</span>);
    }    <span class="rem">// end if(trackDataList.size() &gt; 0)</span>
        
}


<span class="rem">//  logic to select a car number </span>
<span class="kwrd">void</span> CTrackToolDlg::OnCbnSelchangeVehicleId()
{
    <span class="rem">// TODO: Add your control notification handler code here</span>
    
    
    CString theSelection;
    theSelection.Empty();

    <span class="kwrd">int</span> idx;
    
    <span class="kwrd">if</span>(( idx = m_vehicleId.GetCurSel()) &gt; -1)
    {
        m_vehicleId.GetLBText(idx,theSelection);
        sscanf(theSelection,<span class="str">"%d"</span>,&amp;myCarId);
    }
    <span class="kwrd">else</span>
        MessageBox(<span class="str">"Please Select a Car Number or click cancel to Start again"</span>);
        
    <span class="rem">//}</span>

    <span class="kwrd">double</span> lmaxEasting = 0.0;
    <span class="kwrd">double</span> lminEasting = 12000000.0;
    <span class="kwrd">double</span> lmaxNorthing = 0.0;
    <span class="kwrd">double</span> lminNorthing = 12000000.0;

    <span class="kwrd">int</span> i = 0;
    <span class="kwrd">for</span>(trackDataListIterator = trackDataList.begin();
        trackDataListIterator != trackDataList.end();
        trackDataListIterator++)
    {
        temp = *trackDataListIterator;

        <span class="kwrd">if</span>(temp.CarId == myCarId)
        {
            i++;
            <span class="kwrd">double</span> newEast = temp.Easting;
            <span class="kwrd">double</span> newNorth = temp.Northing;

            <span class="kwrd">if</span> (newEast &lt; lminEasting) {
                lminEasting = newEast;
            }

            <span class="kwrd">if</span> (newEast &gt; lmaxEasting) {
                lmaxEasting = newEast;
            }

            <span class="kwrd">if</span> (newNorth &gt; lmaxNorthing) {
                lmaxNorthing = newNorth;
            }

            <span class="kwrd">if</span> (newNorth &lt; lminNorthing) {
                lminNorthing = newNorth;
            }
        }    <span class="rem">// end if(temp.CarId == myCarId)</span>
    }<span class="rem">// end for loop</span>
    m_trackProgress.SetRange(0,i);
    theMap-&gt;minEasting = lminEasting;
    theMap-&gt;maxEasting = lmaxEasting;
    theMap-&gt;minNorthing = lminNorthing;
    theMap-&gt;maxNorthing = lmaxNorthing;

    xFactor = 0.65*(theMap-&gt;maxEasting - theMap-&gt;minEasting);
    yFactor = 0.65*(theMap-&gt;maxNorthing - theMap-&gt;minNorthing);
    
    
    <span class="rem">// Load the input.vdx file and set the origins</span>

    
    
    <span class="kwrd">if</span>(theVisio != NULL)
    {
        theVisio = NULL;
        delete theVisio;
    }

    set_new_handler (newhandler);
    <span class="kwrd">try</span>{
        
        theVisio = <span class="kwrd">new</span> CVisio();
        
    
    }
    <span class="kwrd">catch</span>(bad_alloc &amp;ba)
    {
        em.MessageBox(ba.what(),<span class="str">"Bad Allocation"</span>,MB_OK);
    }
    <span class="kwrd">catch</span>(exception e)
    {
        DWORD dwError = ::GetLastError();
        <span class="kwrd">char</span>* errBuffer;
        errBuffer = NULL;
        sprintf(errBuffer,<span class="str">"%S"</span>,dwError);
        em.MessageBox(errBuffer,<span class="str">""</span>,MB_OK);
    }
    <span class="kwrd">catch</span>(...)
    {
        DWORD dwError = ::GetLastError();
        em.MessageBox(<span class="str">"Unknown Error"</span>,(<span class="kwrd">char</span> *)dwError,MB_OK);
    }
    SUCCESS = VARIANT_TRUE;

    SUCCESS = theVisio-&gt;setOrigins(theMap-&gt;minEasting,theMap-&gt;minNorthing, xFactor, yFactor);
    <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE)
    {
        em.MessageBox(<span class="str">"Problem loading file input.vdx \n "</span>, <span class="str">"File may not exist\n Close and Check"</span>, MB_OK);
        
        OnBnClickedCancelSourceFile();
    }
    <span class="kwrd">else</span>
    {
        <span class="kwrd">try</span>
        {
            dwBufLen = 255;
            <span class="kwrd">if</span>(RegOpenKeyEx(HKEY_LOCAL_MACHINE,<span class="str">"Software\\Sumaria\\TrackTool"</span>,0,KEY_QUERY_VALUE,&amp;hKey) != ERROR_SUCCESS)
                <span class="kwrd">throw</span> <span class="str">" Failed to Open Registry "</span>;
        
            <span class="kwrd">if</span>(RegQueryValueEx(hKey,_T(<span class="str">"InstallPath"</span>),NULL,NULL,(LPBYTE) szProductType,&amp;dwBufLen) != ERROR_SUCCESS)
                <span class="kwrd">throw</span> <span class="str">" Failed to Query Registry "</span>;
            <span class="kwrd">if</span>(RegCloseKey(hKey) != ERROR_SUCCESS) 
                <span class="kwrd">throw</span> <span class="str">" Failed to Close Registry "</span>;

            status = szProductType;
            status.Append(<span class="str">"output.vdx"</span>);
            
            <span class="rem">//status = "c:\\tracktool\\output.vdx";</span>
            m_outputFile.SetWindowText(status);
            MessageBox(<span class="str">"Change output file Name and Click on ...Start Button / Append Button to Append to an existing file"</span>);
            GetDlgItem(IDC_START)-&gt;EnableWindow(TRUE);    
            m_appendFile.EnableWindow(TRUE);
        }    <span class="rem">// end try block</span>
        <span class="kwrd">catch</span>(<span class="kwrd">const</span> <span class="kwrd">char</span> *str)
        {
            em.MessageBox(str,<span class="str">"Check again"</span>,MB_OK);    
        }
        <span class="kwrd">catch</span>(...)
        {
            em.MessageBox(<span class="str">"Unknown Error"</span>,<span class="str">""</span>,MB_OK);
        }

    }    <span class="rem">// end else</span>
    
}

<span class="kwrd">void</span> CTrackToolDlg::OnTimer(UINT nIDEvent)
{
    <span class="rem">// TODO: Add your message handler code here and/or call default</span>

    
    <span class="rem">//CDialog::OnTimer(nIDEvent);</span>
    
    m_createXML.EnableWindow(FALSE);
    
    <span class="kwrd">if</span>(m_DataFile == FALSE)
    {
        <span class="kwrd">if</span>(feof(input))
        {
            KillTimer(1234);
            OnBnClickedCancelSourceFile();
            AfxMessageBox(<span class="str">"Complete Click Ok "</span>,MB_OK | MB_ICONINFORMATION);
        }
        <span class="kwrd">else</span>
        {
            <span class="rem">///////////////////////////////////////////////</span>
            <span class="rem">////////// modifications to accomodate the new GPGGA string ASHTEC data format</span>
            <span class="rem">/////////////////////////////////////</span>
            <span class="rem">/////////////// the new code will determine either the CMC GPGGA string or ASHTEC Board</span>

            <span class="kwrd">char</span> bufferCMC[50];    <span class="rem">// buffer to hold CMC string</span>
            <span class="kwrd">char</span> bufferAshTech[52];    <span class="rem">// buffer to hold ASHTECH string</span>

            <span class="kwrd">while</span>(!feof(input))
            {
                ch = getc(input);
            
                <span class="kwrd">if</span>(((<span class="kwrd">char</span>)ch) == <span class="str">'\n'</span>)
                {
                
                    <span class="kwrd">if</span>(lenOfMsg == 50)
                    {
                        <span class="rem">// CMC board</span>
                    
                        <span class="kwrd">char</span> inputChar = <span class="str">'\0'</span>;
                    
                        <span class="rem">//bufferCMC[0] = inputChar;</span>
                        bufferCMC[49] = <span class="str">'\0'</span>;
                        <span class="kwrd">if</span> (isValidMessage(bufferCMC)) 
                        {
                            Position p(bufferCMC);
                            theGlobalObserver.Notify(p);    
                            <span class="kwrd">if</span>(p.getCarID() == myCarId)
                            {
                                theVisio-&gt;dVPinX = theMap-&gt;easting = p.getEasting();
                                theVisio-&gt;dVPinY = theMap-&gt;northing = p.getNorthing();            
                                theVisio-&gt;dVPinZ = p.getAltitude();
                                theVisio-&gt;dVPinX = (theVisio-&gt;dVPinX - theMap-&gt;minEasting + xFactor) * VISIOFACTOR;
                                theVisio-&gt;dVPinY = (theVisio-&gt;dVPinY - theMap-&gt;minNorthing + yFactor) * VISIOFACTOR;
                                index++;
                                progCtrl++;
                                theVisio-&gt;dShapeIDVal = index;
                                theVisio-&gt;BuildShape(theVisio-&gt;DOMDocumentPtr,theVisio-&gt;DOMNodePtr,theVisio-&gt;xmlShapeList);
                                status = <span class="str">".......Building Visio File ......."</span>;
                                m_status.SetWindowText(status);
                                <span class="rem">//RedrawWindow(NULL,NULL,RDW_INVALIDATE);</span>
                                m_trackProgress.SetPos(progCtrl);
                            }<span class="rem">//if(p.getCarID() == myCarId)</span>
                        }    <span class="rem">// end if (isValidMessage(messageBuffer))</span>
                    }    <span class="rem">// enf if(lenOfMsg == 50)</span>
                    <span class="kwrd">if</span>(lenOfMsg == 52)
                    {
                        <span class="rem">// Ashtech board</span>
                        <span class="kwrd">char</span> inputChar = <span class="str">'\0'</span>;
                    
                        <span class="rem">//bufferAshTech[0] = inputChar;</span>
                        bufferAshTech[51] = <span class="str">'\0'</span>;
                        <span class="kwrd">if</span> (isValidNewMessage(bufferAshTech)) 
                        {
                            NewPosition newp(bufferAshTech);
                            theGlobalObserver.Notify(newp);    
                            <span class="kwrd">if</span>(newp.getCarID() == myCarId)
                            {
                                theVisio-&gt;dVPinX = theMap-&gt;easting = newp.getEasting();
                                theVisio-&gt;dVPinY = theMap-&gt;northing = newp.getNorthing();            
                                theVisio-&gt;dVPinZ = newp.getAltitude();
                                theVisio-&gt;dVPinX = (theVisio-&gt;dVPinX - theMap-&gt;minEasting + xFactor) * VISIOFACTOR;
                                theVisio-&gt;dVPinY = (theVisio-&gt;dVPinY - theMap-&gt;minNorthing + yFactor) * VISIOFACTOR;
                                index++;
                                progCtrl++;
                                theVisio-&gt;dShapeIDVal = index;
                                theVisio-&gt;BuildShape(theVisio-&gt;DOMDocumentPtr,theVisio-&gt;DOMNodePtr,theVisio-&gt;xmlShapeList);
                                status = <span class="str">".......Building Visio File ......."</span>;
                                m_status.SetWindowText(status);
                                <span class="rem">//RedrawWindow(NULL,NULL,RDW_INVALIDATE);</span>
                                m_trackProgress.SetPos(progCtrl);
                            }<span class="rem">//if(newp.getCarID() == myCarId)</span>
                        }    <span class="rem">// end if (isValidMessage(messageBuffer))</span>
                    }    <span class="rem">// end if(lenOfMsg == 52)</span>
                    lenOfMsg = 0;
                }    <span class="rem">// end if(((char)ch) == '\n')</span>
                <span class="kwrd">else</span>
                {    
                    <span class="kwrd">if</span>(lenOfMsg &lt;= 49)
                        bufferCMC[lenOfMsg] = <span class="kwrd">char</span>(ch);
                
                    <span class="kwrd">if</span>(lenOfMsg &lt;= 51)
                        bufferAshTech[lenOfMsg] = <span class="kwrd">char</span>(ch);
                    ++lenOfMsg;
                }    <span class="rem">//end else if(((char)ch) == '\n')</span>
            }    <span class="rem">// end while(!feof(input))</span>
        
            
            <span class="rem">/*</span>
<span class="rem">            char messageBuffer[50];</span>
<span class="rem">            char inputChar = '\0';</span>
<span class="rem"></span>
<span class="rem">            while ((inputChar != '$') &amp;&amp; (!feof(input)))</span>
<span class="rem">                    fread(&amp;inputChar, 1, 1, input);</span>
<span class="rem"></span>
<span class="rem">            messageBuffer[0] = inputChar;</span>
<span class="rem">            fread(&amp;messageBuffer[1], 48, 1, input);</span>
<span class="rem">            messageBuffer[49] = '\0';</span>
<span class="rem">        </span>
<span class="rem">            if (isValidMessage(messageBuffer)) {</span>
<span class="rem">            </span>
<span class="rem">                Position p(messageBuffer);</span>
<span class="rem">                theGlobalObserver.Notify(p);</span>
<span class="rem"></span>
<span class="rem">                if(p.getCarID() == myCarId)</span>
<span class="rem">                {</span>
<span class="rem">                    </span>
<span class="rem">                    theVisio-&gt;dVPinX = theMap-&gt;easting = p.getEasting();</span>
<span class="rem">                    theVisio-&gt;dVPinY = theMap-&gt;northing = p.getNorthing();            </span>
<span class="rem">                    theVisio-&gt;dVPinZ = p.getAltitude();</span>
<span class="rem"></span>
<span class="rem">                    </span>
<span class="rem">                    theVisio-&gt;dVPinX = (theVisio-&gt;dVPinX - theMap-&gt;minEasting + xFactor) * VISIOFACTOR;</span>
<span class="rem">                    theVisio-&gt;dVPinY = (theVisio-&gt;dVPinY - theMap-&gt;minNorthing + yFactor) * VISIOFACTOR;</span>
<span class="rem">                    index++;</span>
<span class="rem">                    progCtrl++;</span>
<span class="rem"></span>
<span class="rem">                    theVisio-&gt;dShapeIDVal = index;</span>
<span class="rem">                    theVisio-&gt;BuildShape(theVisio-&gt;DOMDocumentPtr,theVisio-&gt;DOMNodePtr,theVisio-&gt;xmlShapeList);</span>
<span class="rem">                    status = ".......Building Visio File .......";</span>
<span class="rem">                    m_status.SetWindowText(status);</span>
<span class="rem">                    //RedrawWindow(NULL,NULL,RDW_INVALIDATE);</span>
<span class="rem">                    m_trackProgress.SetPos(progCtrl);</span>
<span class="rem">                }//if(p.getCarID() == myCarId)</span>
<span class="rem">            }    // end if (isValidMessage(messageBuffer))</span>
<span class="rem">            */</span>
        }    <span class="rem">// end else if(feof(input))    </span>
    }
    <span class="kwrd">else</span>    <span class="rem">// dat file</span>
    {    
        <span class="rem">// the input file is a dat file</span>
        <span class="kwrd">if</span>(feof(input))
        {
            KillTimer(1234);
            OnBnClickedCancelSourceFile();    
            AfxMessageBox(<span class="str">"Complete Click Ok "</span>,MB_OK | MB_ICONINFORMATION);
        }
        <span class="kwrd">else</span>
        {
            Position p;
            p.readData(input);
            <span class="kwrd">if</span>(p.getCarID() == myCarId)
            {
                <span class="rem">//UTMPosition pos(p.getLatitude(),p.getLongitude());</span>
                <span class="rem">//p.easting = pos.easting;</span>
                <span class="rem">//p.northing = pos.northing;</span>
                
                theVisio-&gt;dVPinX = theMap-&gt;easting = p.getEasting();
                theVisio-&gt;dVPinY = theMap-&gt;northing = p.getNorthing();            
                theVisio-&gt;dVPinZ = p.getAltitude();
                theVisio-&gt;dVPinX = (theVisio-&gt;dVPinX - theMap-&gt;minEasting + xFactor) * VISIOFACTOR;
                theVisio-&gt;dVPinY = (theVisio-&gt;dVPinY - theMap-&gt;minNorthing + yFactor) * VISIOFACTOR;
                index++;
                progCtrl++;
                theVisio-&gt;dShapeIDVal = index;
                theVisio-&gt;BuildShape(theVisio-&gt;DOMDocumentPtr,theVisio-&gt;DOMNodePtr,theVisio-&gt;xmlShapeList);
                status = <span class="str">".......Building Visio File ......."</span>;
                m_status.SetWindowText(status);
                <span class="rem">//RedrawWindow(NULL,NULL,RDW_INVALIDATE);</span>
                m_trackProgress.SetPos(progCtrl);
            }    <span class="rem">// end if(p.getCarId()</span>
        }    <span class="rem">// end else    </span>
    }    <span class="rem">// end else    </span>
}    <span class="rem">// end OnTimer(...) function</span>

<span class="kwrd">void</span> CTrackToolDlg::OnBnClickedCreateXml()
{
    <span class="rem">// TODO: Add your control notification handler code here</span>
    status = <span class="str">" Select Visio File to create output XML file"</span>;
    m_status.SetWindowText(status);

    m_inputFile.SetWindowText(NULL);
    m_outputFile.SetWindowText(NULL);

    m_createXML.EnableWindow(FALSE);

    GetDlgItem(IDC_DATA_SOURCE_FILE)-&gt;EnableWindow(FALSE);
    progCtrl = 0;
    m_trackProgress.SetPos(progCtrl);
    <span class="kwrd">if</span>(theVisio != NULL)
    {
        theVisio = NULL;
        delete theVisio;
    }


    <span class="kwrd">try</span>{
        theVisio = <span class="kwrd">new</span> CVisio();
    }

    <span class="kwrd">catch</span>(bad_alloc &amp;ba)
    {
        em.MessageBox(ba.what(),<span class="str">""</span>,MB_OK);
    }
    <span class="kwrd">catch</span>(exception e)
    {
        DWORD dwError = ::GetLastError();
        e.what();
        <span class="kwrd">return</span>;
        
    }
    <span class="kwrd">catch</span>(...)
    {
        DWORD dwError = ::GetLastError();

        em.MessageBox(<span class="str">"Unknown Error"</span>,<span class="str">""</span>,MB_OK);
        <span class="kwrd">return</span>;
    }


    <span class="rem">// Open Dialog Box to choose file</span>
    CFileDialog openDialog(TRUE, <span class="str">".*"</span>);
    openDialog.m_ofn.lpstrInitialDir = <span class="str">""</span>;
    openDialog.m_ofn.lpstrFilter = <span class="str">"All Files\0*.*\0\0"</span>;

    <span class="rem">// Return value when the File dialog box opens</span>
    INT_PTR nRet = -1;
    nRet = openDialog.DoModal();

    <span class="rem">// Handle the return value from DoModal</span>
    <span class="kwrd">switch</span> ( nRet )
    {
    <span class="kwrd">case</span> -1: 
        em.MessageBox(<span class="str">"Dialog Box could not be created !"</span>,<span class="str">""</span>,MB_OK);
        <span class="kwrd">break</span>;
    <span class="kwrd">case</span> IDABORT:
        <span class="rem">// Do something</span>
        em.MessageBox(<span class="str">"problem opening file, cause:"</span>, <span class="str">"file may not exist\n Close and Retry"</span>, MB_OK);
        exit(0);
        <span class="kwrd">break</span>;
    <span class="kwrd">case</span> IDOK:
        <span class="kwrd">try</span> 
        {
            SUCCESS = VARIANT_TRUE;
            hr = S_OK;
            status = openDialog.GetPathName();
            m_inputFile.SetWindowText(status);
            vName.Clear();
            m_inputFile.GetWindowText(status);
            vName.SetString(status);
       
            <span class="kwrd">int</span> errThrow = 0;
            theVisio-&gt;DOMDocumentPtr-&gt;validateOnParse = TRUE;
            hr = theVisio-&gt;DOMDocumentPtr-&gt;load(vName);
            <span class="kwrd">if</span>( hr == S_FALSE) <span class="kwrd">throw</span> 2;
            <span class="kwrd">if</span>(theVisio-&gt;DOMDocumentPtr-&gt;readyState != 4)
            {
                <span class="kwrd">while</span>(theVisio-&gt;DOMDocumentPtr-&gt;readyState != 4)
                {
                    ::Sleep(1000);
                }    <span class="rem">// end while</span>
            }    <span class="rem">// end if</span>

            hr = S_OK;    <span class="rem">// reset</span>
            status = <span class="str">" Querying Visio File.... Please Wait "</span>;
            m_status.SetWindowText(status);
            
            
            <span class="rem">// get Origins of the Visio File</span>
            <span class="rem">//theVisio-&gt;DOMNodeListPtr = theVisio-&gt;DOMDocumentPtr-&gt;getElementsByTagName("XRulerOrigin");</span>
            <span class="rem">//ASSERT(theVisio-&gt;DOMNodeListPtr != NULL);</span>
            <span class="rem">//if(theVisio-&gt;DOMNodeListPtr == NULL) throw " Please check the file you selected";</span>
            theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMDocumentPtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Pages/Page/PageSheet/RulerGrid/XRulerOrigin"</span>));
            <span class="rem">//theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodeListPtr-&gt;item[1];</span>
            <span class="rem">//ASSERT(theVisio-&gt;DOMNodePtr != NULL);</span>
            <span class="kwrd">if</span>(theVisio-&gt;DOMNodePtr == NULL) 
                <span class="kwrd">throw</span> <span class="str">" Have you Selected the correct file? "</span>;

            theVisio-&gt;vt.Clear();
            theVisio-&gt;vt = theVisio-&gt;DOMNodePtr-&gt;GetnodeTypedValue();

            m_visXOrigin = myabs(<span class="kwrd">double</span>(theVisio-&gt;vt)/VISIOFACTOR);

            <span class="rem">//theVisio-&gt;DOMNodeListPtr = theVisio-&gt;DOMDocumentPtr-&gt;getElementsByTagName("YRulerOrigin");</span>
            <span class="rem">//ASSERT(theVisio-&gt;DOMNodeListPtr != NULL);</span>
            
            theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMDocumentPtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Pages/Page/PageSheet/RulerGrid/YRulerOrigin"</span>));
            ASSERT(theVisio-&gt;DOMNodePtr != NULL);

            theVisio-&gt;vt.Clear();
            theVisio-&gt;vt = theVisio-&gt;DOMNodePtr-&gt;GetnodeTypedValue();

            m_visYOrigin = myabs(<span class="kwrd">double</span>(theVisio-&gt;vt)/VISIOFACTOR);


            <span class="rem">//////////////////////////////////////////////////////////////////</span>

            <span class="rem">////////////// stuff to create OpenGL init file////////////////////////</span>
            theVisio-&gt;OGLDOMDocumentPtr = NULL;
            theVisio-&gt;OGLDOMDocumentPtr = createDocument();
            theVisio-&gt;OGLDOMDocumentPtr-&gt;async = FALSE;
            theVisio-&gt;OGLDOMDocumentPtr-&gt;validateOnParse = TRUE;
            ASSERT(theVisio-&gt;OGLDOMDocumentPtr != NULL);

            
            theVisio-&gt;OGLDOMNodePtr = NULL;
            theVisio-&gt;OGLDOMNodePtr = theVisio-&gt;OGLDOMDocumentPtr;

            <span class="rem">// theVisio-&gt;fillxmlTrack();creates a list that is the skeleton file for our xml </span>
            <span class="rem">//                            output file</span>
            SUCCESS = theVisio-&gt;fillxmlTrack(); 
            <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">"Unable to build the output.xml List"</span>;

            SUCCESS = VARIANT_TRUE;
            SUCCESS = theVisio-&gt;BuildShape(theVisio-&gt;OGLDOMDocumentPtr,theVisio-&gt;OGLDOMNodePtr,theVisio-&gt;xmlTrackList);
            <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">" Unable to build the output.xml file "</span>;

            SUCCESS = VARIANT_TRUE;

            dwBufLen = 255;
            <span class="kwrd">if</span>(RegOpenKeyEx(HKEY_LOCAL_MACHINE,<span class="str">"Software\\Sumaria\\TrackTool"</span>,0,KEY_QUERY_VALUE,&amp;hKey) != ERROR_SUCCESS)
                <span class="kwrd">throw</span> <span class="str">" Failed to Open Registry "</span>;
            <span class="kwrd">if</span>(RegQueryValueEx(hKey,_T(<span class="str">"InstallPath"</span>),NULL,NULL,(LPBYTE) szProductType,&amp;dwBufLen) != ERROR_SUCCESS)
                <span class="kwrd">throw</span> <span class="str">" Failed to Query Registry "</span>;
            <span class="kwrd">if</span>(RegCloseKey(hKey) != ERROR_SUCCESS) 
                <span class="kwrd">throw</span> <span class="str">" Failed to Close Registry "</span>;

            status = szProductType;
            status.Append(<span class="str">"output.xml"</span>);
            
            m_outputFile.SetWindowText(status);

            MessageBox(<span class="str">" File will be saved as output.xml , Please change name later "</span>);

            ::SetCursor(m_hcurWait);
            
    
            m_outputFile.GetWindowText(status);    <span class="rem">// get the file name</span>
            vName.SetString(status);
            
            hr = theVisio-&gt;OGLDOMDocumentPtr-&gt;save(vName);
            <span class="kwrd">if</span>(hr == S_FALSE) <span class="kwrd">throw</span> <span class="str">"Could not save the ####.xml file"</span>;

            hr = S_OK;
            theVisio-&gt;OGLDOMDocumentPtr-&gt;async = FALSE;
            theVisio-&gt;OGLDOMDocumentPtr-&gt;validateOnParse = TRUE;
            hr = theVisio-&gt;OGLDOMDocumentPtr-&gt;load(vName);
            <span class="kwrd">if</span>(hr == S_FALSE) <span class="kwrd">throw</span> <span class="str">"Could not load the ####.xml file"</span>;

            <span class="rem">///////////////////////////////////////////</span>

            <span class="rem">// if SUCCESSFULL till this point then  do select and other stuff</span>

            <span class="rem">// ///////////////////// query the list based on conditions////////////</span>

            theVisio-&gt;outListPtr = theVisio-&gt;DOMDocumentPtr-&gt;selectNodes(_bstr_t(<span class="str">"//Shape[Geom/Ellipse][XForm/PinX][XForm/PinY]/LayerMem[LayerMember = //Layer[Name = \"outside\"]/@IX]"</span>));
            
            theVisio-&gt;inListPtr = theVisio-&gt;DOMDocumentPtr-&gt;selectNodes(_bstr_t(<span class="str">"//Shape[Geom/Ellipse][XForm/PinX][XForm/PinY]/LayerMem[LayerMember = //Layer[Name = \"inside\"]/@IX]"</span>));

            theVisio-&gt;fullinListPtr = theVisio-&gt;DOMDocumentPtr-&gt;selectNodes(_bstr_t(<span class="str">"//Shape[Geom/Ellipse][XForm/PinX][XForm/PinY]/LayerMem[LayerMember = //Layer[Name = \"fullinside\"]/@IX]"</span>));
            
            theVisio-&gt;pitListPtr = theVisio-&gt;DOMDocumentPtr-&gt;selectNodes(_bstr_t(<span class="str">"//Shape[Geom/Ellipse][XForm/PinX][XForm/PinY]/LayerMem[LayerMember = //Layer[Name = \"pitwall\"]/@IX]"</span>));

            theVisio-&gt;island1ListPtr = theVisio-&gt;DOMDocumentPtr-&gt;selectNodes(_bstr_t(<span class="str">"//Shape[Geom/Ellipse][XForm/PinX][XForm/PinY]/LayerMem[LayerMember = //Layer[Name = \"island1\"]/@IX]"</span>));

            theVisio-&gt;island2ListPtr = theVisio-&gt;DOMDocumentPtr-&gt;selectNodes(_bstr_t(<span class="str">"//Shape[Geom/Ellipse][XForm/PinX][XForm/PinY]/LayerMem[LayerMember = //Layer[Name = \"island2\"]/@IX]"</span>));

            theVisio-&gt;island3ListPtr = theVisio-&gt;DOMDocumentPtr-&gt;selectNodes(_bstr_t(<span class="str">"//Shape[Geom/Ellipse][XForm/PinX][XForm/PinY]/LayerMem[LayerMember = //Layer[Name = \"island3\"]/@IX]"</span>));

            theVisio-&gt;startstopListPtr = theVisio-&gt;DOMDocumentPtr-&gt;selectNodes(_bstr_t(<span class="str">"//Shape[Geom][XForm/PinX][XForm/PinY][XForm1D/BeginX][XForm1D/BeginY][XForm1D/EndX][XForm1D/EndY]/LayerMem[LayerMember = //Layer[Name = \"startstop\"]/@IX]"</span>));

            theVisio-&gt;turnListPtr = theVisio-&gt;DOMDocumentPtr-&gt;selectNodes(_bstr_t(<span class="str">"//Shape[Text][XForm/PinX][XForm/PinY]/LayerMem[LayerMember = //Layer[Name = \"turnno\"]/@IX]"</span>));
            
            theVisio-&gt;speedtrapListPtr = theVisio-&gt;DOMDocumentPtr-&gt;selectNodes(_bstr_t(<span class="str">"//Shape[Geom][XForm/PinX][XForm/PinY][XForm1D/BeginX][XForm1D/BeginY][XForm1D/EndX][XForm1D/EndY]/LayerMem[LayerMember = //Layer[Name = \"speedtrap\"]/@IX]"</span>));    

            theVisio-&gt;zoneInListPtr = theVisio-&gt;DOMDocumentPtr-&gt;selectNodes(_bstr_t(<span class="str">"//Shape[Geom][XForm/PinX][XForm/PinY][XForm1D/BeginX][XForm1D/BeginY][XForm1D/EndX][XForm1D/EndY]/LayerMem[LayerMember = //Layer[Name = \"zonein\"]/@IX]"</span>));    

            theVisio-&gt;zoneOutListPtr = theVisio-&gt;DOMDocumentPtr-&gt;selectNodes(_bstr_t(<span class="str">"//Shape[Geom][XForm/PinX][XForm/PinY][XForm1D/BeginX][XForm1D/BeginY][XForm1D/EndX][XForm1D/EndY]/LayerMem[LayerMember = //Layer[Name = \"zoneout\"]/@IX]"</span>));    
                
            <span class="rem">//theVisio-&gt;shapesListPtr = theVisio-&gt;DOMDocumentPtr-&gt;selectNodes(_bstr_t("//Shape/LayerMem[LayerMember = //Layer[Name = \"shapes\"]/@IX]"));</span>

            

            
            <span class="rem">// I have queried and am now filing in the list</span>

            _variant_t vtOutX,vtOutY,vt;
            _variant_t vtInX,vtInY;
            _variant_t vtFullInX,vtFullInY;
            _variant_t vtPitInX,vtPitInY;
            _variant_t vtIslandX,vtIslandY;
            _variant_t vtStartStopX,vtStartStopY;
            _variant_t vtTurnX,vtTurnY,vtTurnAngle;

            
            <span class="kwrd">if</span>(OutList.empty() == FALSE)
                OutList.clear();

            <span class="kwrd">if</span>(OutCheckedList.empty() == FALSE)
                OutCheckedList.clear();

            <span class="kwrd">if</span>(InList.empty()  == FALSE)
                InList.clear();

            <span class="kwrd">if</span>(InCheckedList.empty() == FALSE)
                InCheckedList.clear();
    
            <span class="kwrd">if</span>(FullInList.empty()  == FALSE)
                FullInList.clear();

            <span class="kwrd">if</span>(FullInCheckedList.empty() == FALSE)
                FullInCheckedList.clear();
    
            <span class="kwrd">if</span>(PitInList.empty()  == FALSE)
                PitInList.clear();

            <span class="kwrd">if</span>(PitInCheckedList.empty() == FALSE)
                PitInCheckedList.clear();

            <span class="kwrd">if</span>(Island1List.empty()  == FALSE)
                Island1List.clear();

            <span class="kwrd">if</span>(Island1CheckedList.empty() == FALSE)
                Island1CheckedList.clear();

            <span class="kwrd">if</span>(Island2List.empty()  == FALSE)
                Island2List.clear();

            <span class="kwrd">if</span>(Island2CheckedList.empty() == FALSE)
                Island2CheckedList.clear();

            <span class="kwrd">if</span>(Island3List.empty()  == FALSE)
                Island3List.clear();

            <span class="kwrd">if</span>(Island3CheckedList.empty() == FALSE)
                Island3CheckedList.clear();

            <span class="kwrd">if</span>(StartStopList.empty() == FALSE)
                StartStopList.clear();

            <span class="kwrd">if</span>(TurnNoList.empty() == FALSE)
                TurnNoList.clear();

            <span class="kwrd">if</span>(speedtrapList.empty() == FALSE)
                    speedtrapList.clear();

            <span class="kwrd">if</span>(ZoneInList.empty() == FALSE)
                ZoneInList.clear();

            <span class="kwrd">if</span>(ZoneOutList.empty() == FALSE)
                ZoneOutList.clear();
<span class="rem">/*</span>
<span class="rem">            if(RectList.empty() == FALSE)</span>
<span class="rem">                RectList.clear();</span>
<span class="rem"></span>
<span class="rem">            if(LineList.empty() == FALSE)</span>
<span class="rem">                LineList.clear();</span>
<span class="rem">*/</span>
            <span class="kwrd">long</span> outCount = 0;
            <span class="kwrd">long</span> inCount =  0;
            <span class="kwrd">long</span> fullinCount =  0;
            <span class="kwrd">long</span> pitCount = 0;
            <span class="kwrd">long</span> island1Count = 0;
            <span class="kwrd">long</span> island2Count = 0;
            <span class="kwrd">long</span> island3Count = 0;
            <span class="kwrd">long</span> startstopCount = 0;
            <span class="kwrd">long</span> turnnoCount = 0;
            <span class="rem">//long shapesCount = 0;</span>
            <span class="kwrd">long</span> speedtrapCount = 0;
            <span class="kwrd">long</span> zoneinCount = 0;
            <span class="kwrd">long</span> zoneoutCount = 0;

            <span class="rem">// the following queries help determin existence of layer names</span>
            <span class="rem">//////////////////////// get the number/count of outsidesegment items</span>
            theVisio-&gt;DOMNodePtr = NULL;
            theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMDocumentPtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Layer[Name = \"outside\"]"</span>));
            <span class="kwrd">if</span>(theVisio-&gt;DOMNodePtr != NULL)
                outCount = theVisio-&gt;outListPtr-&gt;Getlength();
            <span class="kwrd">else</span> <span class="kwrd">throw</span> <span class="str">" Please Check to make sure if OUTSIDE layer of track exists "</span>;

            <span class="rem">//////////////////////// get the number/count of insidesegment items</span>
            theVisio-&gt;DOMNodePtr = NULL;
            theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMDocumentPtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Layer[Name = \"inside\"]"</span>));
            <span class="kwrd">if</span>(theVisio-&gt;DOMNodePtr != NULL)
                inCount = theVisio-&gt;inListPtr-&gt;Getlength();
            <span class="kwrd">else</span>  <span class="kwrd">throw</span> <span class="str">" Please Check to make sure if INSIDE layer of track exists "</span>;

            <span class="rem">//////////////////////// get the number/count of fullinsidesegment items</span>
            theVisio-&gt;DOMNodePtr = NULL;
            theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMDocumentPtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Layer[Name = \"fullinside\"]"</span>));
            <span class="kwrd">if</span>(theVisio-&gt;DOMNodePtr != NULL)
                fullinCount = theVisio-&gt;fullinListPtr-&gt;Getlength();

            <span class="rem">//////////////////////// get the number/count of pitwall items</span>
            theVisio-&gt;DOMNodePtr = NULL;
            theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMDocumentPtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Layer[Name = \"pitwall\"]"</span>));
            <span class="kwrd">if</span>(theVisio-&gt;DOMNodePtr != NULL)
                pitCount = theVisio-&gt;pitListPtr-&gt;Getlength();

            <span class="rem">//////////////////////// get the number/count of island1 items</span>
            theVisio-&gt;DOMNodePtr = NULL;
            theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMDocumentPtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Layer[Name = \"island1\"]"</span>));
            <span class="kwrd">if</span>(theVisio-&gt;DOMNodePtr != NULL)
                island1Count = theVisio-&gt;island1ListPtr-&gt;Getlength();

            <span class="rem">//////////////////////// get the number/count of island2 items</span>
            theVisio-&gt;DOMNodePtr = NULL;
            theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMDocumentPtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Layer[Name = \"island2\"]"</span>));
            <span class="kwrd">if</span>(theVisio-&gt;DOMNodePtr != NULL)
                island2Count = theVisio-&gt;island2ListPtr-&gt;Getlength();

            <span class="rem">//////////////////////// get the number/count of island3 items</span>
            theVisio-&gt;DOMNodePtr = NULL;
            theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMDocumentPtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Layer[Name = \"island3\"]"</span>));
            <span class="kwrd">if</span>(theVisio-&gt;DOMNodePtr != NULL)
                island3Count = theVisio-&gt;island3ListPtr-&gt;Getlength();

            <span class="rem">//////////////////////// get the number/count of startstop items</span>
            theVisio-&gt;DOMNodePtr = NULL;
            theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMDocumentPtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Layer[Name = \"startstop\"]"</span>));
            <span class="kwrd">if</span>(theVisio-&gt;DOMNodePtr != NULL)
                startstopCount = theVisio-&gt;startstopListPtr-&gt;Getlength();

            <span class="rem">////////////// get the number/count of turnnos</span>
            theVisio-&gt;DOMNodePtr = NULL;
            theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMDocumentPtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Layer[Name = \"turnno\"]"</span>));
            <span class="kwrd">if</span>(theVisio-&gt;DOMNodePtr != NULL)
                turnnoCount = theVisio-&gt;turnListPtr-&gt;Getlength();

            theVisio-&gt;DOMNodePtr = NULL;
            theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMDocumentPtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Layer[Name = \"speedtrap\"]"</span>));
            <span class="kwrd">if</span>(theVisio-&gt;DOMNodePtr != NULL)
                speedtrapCount = theVisio-&gt;speedtrapListPtr-&gt;Getlength();

            theVisio-&gt;DOMNodePtr = NULL;
            theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMDocumentPtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Layer[Name = \"zonein\"]"</span>));
            <span class="kwrd">if</span>(theVisio-&gt;DOMNodePtr != NULL)
                zoneinCount = theVisio-&gt;zoneInListPtr-&gt;Getlength();

            theVisio-&gt;DOMNodePtr = NULL;
            theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMDocumentPtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Layer[Name = \"zoneout\"]"</span>));
            <span class="kwrd">if</span>(theVisio-&gt;DOMNodePtr != NULL)
                zoneoutCount = theVisio-&gt;zoneOutListPtr-&gt;Getlength();

<span class="rem">/*</span>
<span class="rem"></span>
<span class="rem">            ////////////// get the number/count of shapes</span>
<span class="rem">            //theVisio-&gt;DOMNodePtr = NULL;</span>
<span class="rem">            //theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMDocumentPtr-&gt;selectSingleNode(_bstr_t("//Layer[Name = \"shapes\"]"));</span>
<span class="rem">            //if(theVisio-&gt;DOMNodePtr != NULL)</span>
<span class="rem">                shapesCount = theVisio-&gt;shapesListPtr-&gt;Getlength();</span>
<span class="rem"></span>
<span class="rem">*/</span>
            <span class="rem">// set the range for the progress control</span>
            m_trackProgress.SetRange(0,(<span class="kwrd">int</span>)(outCount+inCount+pitCount+startstopCount+turnnoCount+speedtrapCount+zoneinCount+zoneoutCount));
            <span class="rem">// make the DOMNodePtr NULL;</span>

            theVisio-&gt;DOMNodePtr = NULL;
            <span class="kwrd">for</span>(<span class="kwrd">int</span> i = 0; i &lt; outCount; i++)
            {
                theVisio-&gt;DOMNodePtr = theVisio-&gt;outListPtr-&gt;item[i];
                theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;GetparentNode();
                <span class="rem">//theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;firstChild;</span>

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(0);</span>

                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm/PinX"</span>));
                vtOutX = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdXOut = (<span class="kwrd">double</span>(vtOutX)/VISIOFACTOR) + m_visXOrigin;

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(1);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm/PinY"</span>));
                vtOutY = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdYOut = (<span class="kwrd">double</span>(vtOutY)/VISIOFACTOR) + m_visYOrigin;

                theVisio-&gt;pChild = NULL;
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label =\"Altitude\" or @NameU = \"Altitude\"]/Value"</span>));
                <span class="kwrd">if</span>(theVisio-&gt;pChild  == NULL)
                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label = \"Altitude\"]/Value"</span>));
                    
                <span class="kwrd">if</span>(theVisio-&gt;pChild != NULL)
                {
                    vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                    theVisio-&gt;gdZOut = <span class="kwrd">double</span>(vt);
                }
                <span class="kwrd">else</span>
                    theVisio-&gt;gdZOut = 0.0;

                tempMap.Easting = theVisio-&gt;gdXOut;
                tempMap.Northing = theVisio-&gt;gdYOut;
                tempMap.Altitude = theVisio-&gt;gdZOut;

                OutList.push_back(tempMap);
            }    <span class="rem">// end for</span>

            
            theVisio-&gt;DOMNodePtr = NULL;
            <span class="kwrd">for</span>(<span class="kwrd">int</span> j = 0; j &lt; inCount; j++)
            {
                theVisio-&gt;DOMNodePtr = theVisio-&gt;inListPtr-&gt;item[j];
                theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;GetparentNode();
                <span class="rem">//theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;firstChild;</span>

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(0);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm/PinX"</span>));
                vtInX = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdXIn = (<span class="kwrd">double</span>(vtInX)/VISIOFACTOR) + m_visXOrigin;

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(1);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm/PinY"</span>));
                vtInY = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdYIn = (<span class="kwrd">double</span>(vtInY)/VISIOFACTOR) + m_visYOrigin;

                theVisio-&gt;pChild = NULL;
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label =\"Altitude\" or @NameU = \"Altitude\"]/Value"</span>));        
                <span class="kwrd">if</span>(theVisio-&gt;pChild  == NULL)
                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label = \"Altitude\"]/Value"</span>));
                <span class="rem">//if(theVisio-&gt;pChild  == NULL)</span>
                <span class="rem">//    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t("Prop[Label = \"Altitude\" or @ID = 1 or @ID = 2]/Value"));</span>
                    
                <span class="kwrd">if</span>(theVisio-&gt;pChild != NULL)
                {
                    vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                    theVisio-&gt;gdZIn = <span class="kwrd">double</span>(vt);
                }
                <span class="kwrd">else</span>
                    theVisio-&gt;gdZIn = 0.0;

                
                tempMap.Easting = theVisio-&gt;gdXIn;
                tempMap.Northing = theVisio-&gt;gdYIn;
                tempMap.Altitude = theVisio-&gt;gdZIn;

                InList.push_back(tempMap);
            }    <span class="rem">// end for</span>

            <span class="rem">// fullincount</span>
            theVisio-&gt;DOMNodePtr = NULL;
            <span class="kwrd">for</span>(<span class="kwrd">int</span> fj = 0; fj &lt; fullinCount; fj++)
            {
                theVisio-&gt;DOMNodePtr = theVisio-&gt;fullinListPtr-&gt;item[fj];
                theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;GetparentNode();
                <span class="rem">//theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;firstChild;</span>

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(0);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm/PinX"</span>));
                vtFullInX = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdXFullIn = (<span class="kwrd">double</span>(vtFullInX)/VISIOFACTOR) + m_visXOrigin;

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(1);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm/PinY"</span>));
                vtFullInY = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdYFullIn = (<span class="kwrd">double</span>(vtFullInY)/VISIOFACTOR) + m_visYOrigin;

                theVisio-&gt;pChild = NULL;
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label =\"Altitude\" or @NameU = \"Altitude\"]/Value"</span>));        
                <span class="kwrd">if</span>(theVisio-&gt;pChild  == NULL)
                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label = \"Altitude\"]/Value"</span>));
                    
                <span class="kwrd">if</span>(theVisio-&gt;pChild != NULL)
                {
                    vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                    theVisio-&gt;gdZFullIn = <span class="kwrd">double</span>(vt);
                }
                <span class="kwrd">else</span>
                    theVisio-&gt;gdZFullIn = 0.0;

                
                tempMap.Easting = theVisio-&gt;gdXFullIn;
                tempMap.Northing = theVisio-&gt;gdYFullIn;
                tempMap.Altitude = theVisio-&gt;gdZFullIn;

                FullInList.push_back(tempMap);
            }    <span class="rem">// end for</span>

            
            theVisio-&gt;DOMNodePtr = NULL;
            <span class="kwrd">for</span>(<span class="kwrd">int</span> k = 0; k &lt; pitCount; k++)
            {
                theVisio-&gt;DOMNodePtr = theVisio-&gt;pitListPtr-&gt;item[k];
                theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;GetparentNode();
                <span class="rem">//theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;firstChild;</span>

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(0);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm/PinX"</span>));
                vtPitInX = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdXPitIn = (<span class="kwrd">double</span>(vtPitInX)/VISIOFACTOR) + m_visXOrigin;

                
                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(1);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm/PinY"</span>));
                vtPitInY = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdYPitIn = (<span class="kwrd">double</span>(vtPitInY)/VISIOFACTOR) + m_visYOrigin;

                theVisio-&gt;pChild = NULL;
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label =\"Altitude\" or @NameU = \"Altitude\"]/Value"</span>));
                <span class="kwrd">if</span>(theVisio-&gt;pChild  == NULL)
                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label = \"Altitude\"]/Value"</span>));
                    
                <span class="kwrd">if</span>(theVisio-&gt;pChild != NULL)
                {
                    vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                    theVisio-&gt;gdZPitIn = <span class="kwrd">double</span>(vt);
                }
                <span class="kwrd">else</span>
                    theVisio-&gt;gdZPitIn = 0.0;

                
                tempMap.Easting = theVisio-&gt;gdXPitIn;
                tempMap.Northing = theVisio-&gt;gdYPitIn;
                tempMap.Altitude = theVisio-&gt;gdZPitIn;

                PitInList.push_back(tempMap);
            }    <span class="rem">// end for</span>

            
            theVisio-&gt;DOMNodePtr = NULL;
            <span class="kwrd">for</span>(<span class="kwrd">int</span> i1 = 0; i1 &lt; island1Count; i1++)
            {
                theVisio-&gt;DOMNodePtr = theVisio-&gt;island1ListPtr-&gt;item[i1];
                theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;GetparentNode();
                <span class="rem">//theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;firstChild;</span>

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(0);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm/PinX"</span>));
                vtPitInX = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdXPitIn = (<span class="kwrd">double</span>(vtPitInX)/VISIOFACTOR) + m_visXOrigin;

                
                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(1);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm/PinY"</span>));
                vtPitInY = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdYPitIn = (<span class="kwrd">double</span>(vtPitInY)/VISIOFACTOR) + m_visYOrigin;

                theVisio-&gt;pChild = NULL;
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label =\"Altitude\" or @NameU = \"Altitude\"]/Value"</span>));
                <span class="kwrd">if</span>(theVisio-&gt;pChild  == NULL)
                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label = \"Altitude\"]/Value"</span>));
                    
                <span class="kwrd">if</span>(theVisio-&gt;pChild != NULL)
                {
                    vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                    theVisio-&gt;gdZPitIn = <span class="kwrd">double</span>(vt);
                }
                <span class="kwrd">else</span>
                    theVisio-&gt;gdZPitIn = 0.0;

                
                tempMap.Easting = theVisio-&gt;gdXPitIn;
                tempMap.Northing = theVisio-&gt;gdYPitIn;
                tempMap.Altitude = theVisio-&gt;gdZPitIn;

                Island1List.push_back(tempMap);
            }    <span class="rem">// end for</span>

            

            <span class="rem">/*</span>
<span class="rem">            theVisio-&gt;DOMNodePtr = NULL;</span>
<span class="rem">            for(int l = 0; l &lt; startstopCount; l++)</span>
<span class="rem">            {</span>
<span class="rem">                theVisio-&gt;DOMNodePtr = theVisio-&gt;startstopListPtr-&gt;item[l];</span>
<span class="rem">                theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;GetparentNode();</span>
<span class="rem">                //theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;firstChild;</span>
<span class="rem"></span>
<span class="rem">                //theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(0);</span>
<span class="rem">                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t("XForm/PinX"));</span>
<span class="rem">                vtStartStopX = theVisio-&gt;pChild-&gt;GetnodeTypedValue();</span>
<span class="rem">                theVisio-&gt;gdXStartStop = (double(vtStartStopX)/VISIOFACTOR) + m_visXOrigin;</span>
<span class="rem"></span>
<span class="rem">                //theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(1);</span>
<span class="rem">                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t("XForm/PinY"));</span>
<span class="rem">                vtStartStopY = theVisio-&gt;pChild-&gt;GetnodeTypedValue();</span>
<span class="rem">                theVisio-&gt;gdYStartStop = (double(vtStartStopY)/VISIOFACTOR) + m_visYOrigin;</span>
<span class="rem"></span>
<span class="rem">                theVisio-&gt;pChild = NULL;</span>
<span class="rem">                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t("Prop[Label =\"Altitude\" or @NameU = \"Altitude\"]/Value"));</span>
<span class="rem">                if(theVisio-&gt;pChild != NULL)</span>
<span class="rem">                {</span>
<span class="rem">                    vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();</span>
<span class="rem">                    theVisio-&gt;gdZStartStop = double(vt);</span>
<span class="rem">                }</span>
<span class="rem">                else</span>
<span class="rem">                    theVisio-&gt;gdZStartStop = 0.0;</span>
<span class="rem"></span>
<span class="rem">                </span>
<span class="rem">                tempMap.Easting = theVisio-&gt;gdXStartStop;</span>
<span class="rem">                tempMap.Northing = theVisio-&gt;gdYStartStop;</span>
<span class="rem">                tempMap.Altitude = theVisio-&gt;gdZStartStop;</span>
<span class="rem"></span>
<span class="rem">                StartStopList.push_back(tempMap);</span>
<span class="rem">            }    // end for</span>
<span class="rem"></span>
<span class="rem">            */</span>
        
            theVisio-&gt;DOMNodePtr = NULL;
            <span class="kwrd">for</span>(<span class="kwrd">int</span> l = 0; l &lt; startstopCount; l++)
            {
                theVisio-&gt;DOMNodePtr = theVisio-&gt;startstopListPtr-&gt;item[l];
                theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;GetparentNode();
                <span class="rem">//theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;firstChild;</span>

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(0);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm1D/BeginX"</span>));
                vtStartStopX = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdX = (<span class="kwrd">double</span>(vtStartStopX)/VISIOFACTOR) + m_visXOrigin;

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(1);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm1D/BeginY"</span>));
                vtStartStopY = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdY = (<span class="kwrd">double</span>(vtStartStopY)/VISIOFACTOR) + m_visYOrigin;

                theVisio-&gt;pChild = NULL;
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[@NameU = \"Altitude\"]/Value"</span>));
                <span class="kwrd">if</span>(theVisio-&gt;pChild  == NULL)
                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label = \"Altitude\"]/Value"</span>));
                <span class="kwrd">if</span>(theVisio-&gt;pChild != NULL)
                {
                    vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                    theVisio-&gt;gdZ = <span class="kwrd">double</span>(vt);
                }
                <span class="kwrd">else</span>
                    theVisio-&gt;gdZ = 0.0;
                    

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(0);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm1D/EndX"</span>));
                vtStartStopX = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdEndX = (<span class="kwrd">double</span>(vtStartStopX)/VISIOFACTOR) + m_visXOrigin;

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(1);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm1D/EndY"</span>));
                vtStartStopY = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdEndY = (<span class="kwrd">double</span>(vtStartStopY)/VISIOFACTOR) + m_visYOrigin;

                theVisio-&gt;pChild = NULL;
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[@NameU = \"Altitude\"]/Value"</span>));
                <span class="kwrd">if</span>(theVisio-&gt;pChild  == NULL)
                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label = \"Altitude\"]/Value"</span>));
                <span class="kwrd">if</span>(theVisio-&gt;pChild != NULL)
                {
                    vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                    theVisio-&gt;gdEndZ = <span class="kwrd">double</span>(vt);
                }
                <span class="kwrd">else</span>
                    theVisio-&gt;gdEndZ = 0.0;
                

                startstop.BeginX = theVisio-&gt;gdX;
                startstop.BeginY = theVisio-&gt;gdY;
                startstop.BeginZ = theVisio-&gt;gdZ;
                startstop.EndX = theVisio-&gt;gdEndX;
                startstop.EndY = theVisio-&gt;gdEndY;
                startstop.EndZ = theVisio-&gt;gdEndZ;
                StartStopList.push_back(startstop);

                
            }    <span class="rem">// end for(int l = 0; l &lt; startstopCount; l++)</span>

            theVisio-&gt;DOMNodePtr = NULL;
            <span class="kwrd">for</span>(<span class="kwrd">int</span> m = 0; m &lt; turnnoCount; m++)
            {
                theVisio-&gt;DOMNodePtr = theVisio-&gt;turnListPtr-&gt;item[m];
                theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;GetparentNode();
                <span class="rem">//theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;firstChild;</span>

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(0);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm/PinX"</span>));
                vtTurnX = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdXTurn = (<span class="kwrd">double</span>(vtTurnX)/VISIOFACTOR) + m_visXOrigin;

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(1);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm/PinY"</span>));
                vtTurnY = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdYTurn = (<span class="kwrd">double</span>(vtTurnY)/VISIOFACTOR) + m_visYOrigin;

                theVisio-&gt;pChild = NULL;
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label =\"Altitude\" or @NameU = \"Altitude\"]/Value"</span>));
                <span class="kwrd">if</span>(theVisio-&gt;pChild  == NULL)
                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label = \"Altitude\"]/Value"</span>));
                <span class="kwrd">if</span>(theVisio-&gt;pChild != NULL)
                {
                    vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                    theVisio-&gt;gdZTurn = <span class="kwrd">double</span>(vt);
                }
                <span class="kwrd">else</span>
                    theVisio-&gt;gdZTurn = 0.0;

                
                <span class="rem">//// logic to access turnNo/Value</span>
                theVisio-&gt;pChild = NULL;
                <span class="kwrd">if</span>((theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Text"</span>))) != NULL)
                    theVisio-&gt;gdTurnNo = theVisio-&gt;pChild-&gt;Gettext();

                <span class="rem">////////// logic to access the font name : default Arial</span>
                
                <span class="kwrd">if</span>((theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Char/Font"</span>))) == NULL)
                {
                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Fonts/FontEntry[@ID = 0]/@Name"</span>));
                    <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMElementPtr-&gt;get_attributes(&amp;theVisio-&gt;pTurnAttrib);</span>
                    <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;pTurnAttrib-&gt;Getitem(4);</span>
                    theVisio-&gt;gdFontType = theVisio-&gt;pChild-&gt;Gettext();
                    
                }
                <span class="kwrd">else</span>
                {
                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Fonts/FontEntry[@ID = //Shape/Char/Font]/@Name"</span>));
                    <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMElementPtr-&gt;get_attributes(&amp;theVisio-&gt;pTurnAttrib);</span>
                    <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;pTurnAttrib-&gt;Getitem(4);</span>
                    theVisio-&gt;gdFontType = theVisio-&gt;pChild-&gt;Gettext();
                }
                
                <span class="rem">// code to access the turn Angle</span>

                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm/Angle"</span>));
                vtTurnAngle = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdTurnAngle = INT64(<span class="kwrd">double</span>(vtTurnAngle)/0.017453292519943);

                turn.Easting = theVisio-&gt;gdXTurn;
                turn.Northing = theVisio-&gt;gdYTurn;
                turn.Altitude = theVisio-&gt;gdZTurn;
                turn.Turnvalue = theVisio-&gt;gdTurnNo;
                turn.TurnfontType = theVisio-&gt;gdFontType;
                turn.TurnAngle = theVisio-&gt;gdTurnAngle;

                TurnNoList.push_back(turn);
                
            }    <span class="rem">// end for for(int m = 0; m &lt; turnnoCount; m++)</span>

            <span class="rem">// speedtrapList</span>
            theVisio-&gt;DOMNodePtr = NULL;
            <span class="kwrd">for</span>(<span class="kwrd">int</span> n = 0; n &lt; speedtrapCount; n++)
            {
                theVisio-&gt;DOMNodePtr = theVisio-&gt;speedtrapListPtr-&gt;item[n];
                theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;GetparentNode();
                <span class="rem">//theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;firstChild;</span>

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(0);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm1D/BeginX"</span>));
                vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdX = (<span class="kwrd">double</span>(vt)/VISIOFACTOR) + m_visXOrigin;

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(1);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm1D/BeginY"</span>));
                vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdY = (<span class="kwrd">double</span>(vt)/VISIOFACTOR) + m_visYOrigin;

                theVisio-&gt;pChild = NULL;
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label =\"Altitude\" or @NameU = \"Altitude\"]/Value"</span>));
                <span class="kwrd">if</span>(theVisio-&gt;pChild  == NULL)
                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label = \"Altitude\"]/Value"</span>));
                <span class="kwrd">if</span>(theVisio-&gt;pChild != NULL)
                {
                    vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                    theVisio-&gt;gdZ = <span class="kwrd">double</span>(vt);
                }
                <span class="kwrd">else</span>
                    theVisio-&gt;gdZ = 0.0;

                    
                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(0);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm1D/EndX"</span>));
                vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdEndX = (<span class="kwrd">double</span>(vt)/VISIOFACTOR) + m_visXOrigin;

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(1);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm1D/EndY"</span>));
                vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdEndY = (<span class="kwrd">double</span>(vt)/VISIOFACTOR) + m_visYOrigin;

                theVisio-&gt;pChild = NULL;
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label =\"Altitude\" or @NameU = \"Altitude\"]/Value"</span>));
                <span class="kwrd">if</span>(theVisio-&gt;pChild  == NULL)
                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label = \"Altitude\"]/Value"</span>));
                    
                <span class="kwrd">if</span>(theVisio-&gt;pChild != NULL)
                {
                    vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                    theVisio-&gt;gdEndZ = <span class="kwrd">double</span>(vt);
                }
                <span class="kwrd">else</span>
                    theVisio-&gt;gdEndZ = 0.0;

                <span class="rem">//// logic to access speedtrapName</span>
                theVisio-&gt;pChild = NULL;
                <span class="kwrd">if</span>((theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Text"</span>))) != NULL)
                    theVisio-&gt;gdName = theVisio-&gt;pChild-&gt;Gettext();

                speedtrap.BeginX = theVisio-&gt;gdX;
                speedtrap.BeginY = theVisio-&gt;gdY;
                speedtrap.BeginZ = theVisio-&gt;gdZ;
                speedtrap.EndX = theVisio-&gt;gdEndX;
                speedtrap.EndY = theVisio-&gt;gdEndY;
                speedtrap.EndZ = theVisio-&gt;gdEndZ;
                speedtrap.speedtrapName = theVisio-&gt;gdName;
                speedtrapList.push_back(speedtrap);
                    
            }    <span class="rem">// end for for(int n = 0; n &lt; speedtrapCount; n++)</span>

            <span class="rem">// zoneinList</span>
            theVisio-&gt;DOMNodePtr = NULL;
            <span class="kwrd">for</span>(<span class="kwrd">int</span> o = 0; o &lt; zoneinCount; o++)
            {
                theVisio-&gt;DOMNodePtr = theVisio-&gt;zoneInListPtr-&gt;item[o];
                theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;GetparentNode();
                <span class="rem">//theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;firstChild;</span>

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(0);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm1D/BeginX"</span>));
                vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdXZoneIn1 = (<span class="kwrd">double</span>(vt)/VISIOFACTOR) + m_visXOrigin;

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(1);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm1D/BeginY"</span>));
                vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdYZoneIn1 = (<span class="kwrd">double</span>(vt)/VISIOFACTOR) + m_visYOrigin;

                theVisio-&gt;pChild = NULL;
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label =\"Altitude\" or @NameU = \"Altitude\"]/Value"</span>));
                <span class="kwrd">if</span>(theVisio-&gt;pChild  == NULL)
                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label = \"Altitude\"]/Value"</span>));
                    
                <span class="kwrd">if</span>(theVisio-&gt;pChild != NULL)
                {
                    vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                    theVisio-&gt;gdZZoneIn1 = <span class="kwrd">double</span>(vt);
                }
                <span class="kwrd">else</span>
                    theVisio-&gt;gdZZoneIn1 = 0.0;

                    
                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(0);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm1D/EndX"</span>));
                vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdXZoneIn2 = (<span class="kwrd">double</span>(vt)/VISIOFACTOR) + m_visXOrigin;

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(1);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm1D/EndY"</span>));
                vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdYZoneIn2 = (<span class="kwrd">double</span>(vt)/VISIOFACTOR) + m_visYOrigin;

                theVisio-&gt;pChild = NULL;
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label =\"Altitude\" or @NameU = \"Altitude\"]/Value"</span>));
                <span class="kwrd">if</span>(theVisio-&gt;pChild  == NULL)
                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label = \"Altitude\"]/Value"</span>));    
                <span class="kwrd">if</span>(theVisio-&gt;pChild != NULL)
                {
                    vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                    theVisio-&gt;gdZZoneIn2 = <span class="kwrd">double</span>(vt);
                }
                <span class="kwrd">else</span>
                    theVisio-&gt;gdZZoneIn2 = 0.0;

                <span class="rem">//// logic to access speedtrapName</span>
                theVisio-&gt;pChild = NULL;
                <span class="kwrd">if</span>((theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Text"</span>))) != NULL)
                    theVisio-&gt;gdZoneName = theVisio-&gt;pChild-&gt;Gettext();

                zonein.BeginX = theVisio-&gt;gdXZoneIn1;
                zonein.BeginY = theVisio-&gt;gdYZoneIn1;
                zonein.BeginZ = theVisio-&gt;gdZZoneIn1;
                zonein.EndX = theVisio-&gt;gdXZoneIn2;
                zonein.EndY = theVisio-&gt;gdYZoneIn2;
                zonein.EndZ = theVisio-&gt;gdZZoneIn2;
                zonein.speedtrapName = theVisio-&gt;gdZoneName;
                ZoneInList.push_back(zonein);
                    
            }    <span class="rem">// end for for(int o = 0; o &lt; zoneinCount; o++)</span>

            <span class="rem">// zoneoutList</span>
            theVisio-&gt;DOMNodePtr = NULL;
            <span class="kwrd">for</span>(<span class="kwrd">int</span> p = 0; p &lt; zoneoutCount; p++)
            {
                theVisio-&gt;DOMNodePtr = theVisio-&gt;zoneOutListPtr-&gt;item[p];
                theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;GetparentNode();
                <span class="rem">//theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;firstChild;</span>

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(0);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm1D/BeginX"</span>));
                vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdXZoneOut1 = (<span class="kwrd">double</span>(vt)/VISIOFACTOR) + m_visXOrigin;

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(1);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm1D/BeginY"</span>));
                vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdYZoneOut1 = (<span class="kwrd">double</span>(vt)/VISIOFACTOR) + m_visYOrigin;

                theVisio-&gt;pChild = NULL;
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label =\"Altitude\" or @NameU = \"Altitude\"]/Value"</span>));
                <span class="kwrd">if</span>(theVisio-&gt;pChild  == NULL)
                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label = \"Altitude\"]/Value"</span>));    
                <span class="kwrd">if</span>(theVisio-&gt;pChild != NULL)
                {
                    vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                    theVisio-&gt;gdZZoneOut1 = <span class="kwrd">double</span>(vt);
                }
                <span class="kwrd">else</span>
                    theVisio-&gt;gdZZoneOut1 = 0.0;

                    
                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(0);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm1D/EndX"</span>));
                vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdXZoneOut2 = (<span class="kwrd">double</span>(vt)/VISIOFACTOR) + m_visXOrigin;

                <span class="rem">//theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;childNodes-&gt;Getitem(1);</span>
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"XForm1D/EndY"</span>));
                vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                theVisio-&gt;gdYZoneOut2 = (<span class="kwrd">double</span>(vt)/VISIOFACTOR) + m_visYOrigin;

                theVisio-&gt;pChild = NULL;
                theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label =\"Altitude\" or @NameU = \"Altitude\"]/Value"</span>));
                <span class="kwrd">if</span>(theVisio-&gt;pChild  == NULL)
                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Prop[Label = \"Altitude\"]/Value"</span>));    
                <span class="kwrd">if</span>(theVisio-&gt;pChild != NULL)
                {
                    vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();
                    theVisio-&gt;gdZZoneOut2 = <span class="kwrd">double</span>(vt);
                }
                <span class="kwrd">else</span>
                    theVisio-&gt;gdZZoneOut2 = 0.0;

                <span class="rem">//// logic to access speedtrapName</span>
                theVisio-&gt;pChild = NULL;
                <span class="kwrd">if</span>((theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t(<span class="str">"Text"</span>))) != NULL)
                    theVisio-&gt;gdZoneName = theVisio-&gt;pChild-&gt;Gettext();

                zonein.BeginX = theVisio-&gt;gdXZoneOut1;
                zonein.BeginY = theVisio-&gt;gdYZoneOut1;
                zonein.BeginZ = theVisio-&gt;gdZZoneOut1;
                zonein.EndX = theVisio-&gt;gdXZoneOut2;
                zonein.EndY = theVisio-&gt;gdYZoneOut2;
                zonein.EndZ = theVisio-&gt;gdZZoneOut2;
                zonein.speedtrapName = theVisio-&gt;gdZoneName;
                ZoneOutList.push_back(zonein);
                    
            }    <span class="rem">// end for for(int p = 0; p &lt; zoneoutCount; p++)</span>

            
            <span class="rem">/*</span>
<span class="rem">            theVisio-&gt;DOMNodePtr = NULL;</span>
<span class="rem">            for(int n = 0; n &lt; shapesCount; n++)</span>
<span class="rem">            {</span>
<span class="rem">                </span>
<span class="rem">                _variant_t v_Height,v_Width;</span>
<span class="rem">                theVisio-&gt;DOMNodePtr = theVisio-&gt;shapesListPtr-&gt;item[n];</span>
<span class="rem">                if((theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t("//Shape[Geom][XForm/PinX][XForm/PinY][XForm/Width][XForm/Height]"))) != NULL)</span>
<span class="rem">                {</span>
<span class="rem">                    </span>
<span class="rem">                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t("XForm/Width"));</span>
<span class="rem">                    v_Width = theVisio-&gt;pChild-&gt;GetnodeTypedValue();</span>
<span class="rem">                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t("XForm/Height"));</span>
<span class="rem">                    v_Height = theVisio-&gt;pChild-&gt;GetnodeTypedValue();</span>
<span class="rem"></span>
<span class="rem">                    /// top left X Co-Ordinate and bottom right X Co-Ordinate of Rectangle</span>
<span class="rem">                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t("XForm/PinX"));</span>
<span class="rem">                    vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();</span>
<span class="rem">                    theVisio-&gt;gdXRect0 = (double(vt) - (0.5 * double(v_Width)))/VISIOFACTOR + m_visXOrigin;</span>
<span class="rem">                    theVisio-&gt;gdXRect1 = (double(vt) - (0.5 * double(v_Width)))/VISIOFACTOR + m_visXOrigin;</span>
<span class="rem">                    theVisio-&gt;gdXRect2 = (double(vt) + (0.5 * double(v_Width)))/VISIOFACTOR + m_visXOrigin;</span>
<span class="rem">                    theVisio-&gt;gdXRect3 = (double(vt) + (0.5 * double(v_Width)))/VISIOFACTOR + m_visXOrigin;</span>
<span class="rem"></span>
<span class="rem">                    /// top left Y Co-Ordinate and bottom right Y Co-Ordinate of Rectangle</span>
<span class="rem">                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t("XForm/PinY"));</span>
<span class="rem">                    vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();</span>
<span class="rem">                    theVisio-&gt;gdYRect0 = (double(vt) + (0.5 * double(v_Height)))/VISIOFACTOR + m_visYOrigin;</span>
<span class="rem">                    theVisio-&gt;gdYRect1 = (double(vt) - (0.5 * double(v_Height)))/VISIOFACTOR + m_visYOrigin;</span>
<span class="rem">                    theVisio-&gt;gdYRect2 = (double(vt) - (0.5 * double(v_Height)))/VISIOFACTOR + m_visYOrigin;</span>
<span class="rem">                    theVisio-&gt;gdYRect3 = (double(vt) + (0.5 * double(v_Height)))/VISIOFACTOR + m_visYOrigin;</span>
<span class="rem"></span>
<span class="rem">                    theVisio-&gt;pChild = NULL;</span>
<span class="rem">                    theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t("Prop[Label =\"Altitude\" or @NameU = \"Altitude\"]/Value"));</span>
<span class="rem">                    </span>
<span class="rem">                    if(theVisio-&gt;pChild != NULL)</span>
<span class="rem">                    {</span>
<span class="rem">                        vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();</span>
<span class="rem">                        theVisio-&gt;gdZRect0 = double(vt);</span>
<span class="rem">                        theVisio-&gt;gdZRect1 = double(vt);</span>
<span class="rem">                        theVisio-&gt;gdZRect2 = double(vt);</span>
<span class="rem">                        theVisio-&gt;gdZRect3 = double(vt);</span>
<span class="rem">                    }</span>
<span class="rem">                    else</span>
<span class="rem">                    {</span>
<span class="rem">                        theVisio-&gt;gdZRect0 = 0.0;</span>
<span class="rem">                        theVisio-&gt;gdZRect1 = 0.0;</span>
<span class="rem">                        theVisio-&gt;gdZRect2 = 0.0;</span>
<span class="rem">                        theVisio-&gt;gdZRect3 = 0.0;</span>
<span class="rem">                    }</span>
<span class="rem">                    ////////////////////////////////</span>
<span class="rem">                    //// lineWeight and lineColor</span>
<span class="rem">                    theVisio-&gt;pChild = NULL;</span>
<span class="rem">                    if((theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t("//Shape/Line/LineWeight"))) != NULL)</span>
<span class="rem">                    {</span>
<span class="rem">                        vt = theVisio-&gt;pChild-&gt;GetnodeTypedValue();</span>
<span class="rem">                        theVisio-&gt;gdLineWeight = double(vt) * 72.0;</span>
<span class="rem">                    }</span>
<span class="rem">                    else</span>
<span class="rem">                    {</span>
<span class="rem">                        theVisio-&gt;gdLineWeight = 0.72;</span>
<span class="rem">                    }</span>
<span class="rem">                    </span>
<span class="rem">                    theVisio-&gt;pChild = NULL;</span>
<span class="rem">                    if((theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t("//Shape/Line/LineColor"))) != NULL)</span>
<span class="rem">                    {</span>
<span class="rem">                        char *RGBVal,val1,val2,val3,val4,val5,val6;</span>
<span class="rem">                        int valNum;</span>
<span class="rem">                        RGBVal = NULL;</span>
<span class="rem">                        vt = theVisio-&gt;pChild-&gt;Gettext();</span>
<span class="rem">                        RGBVal = _com_util::ConvertBSTRToString(vt.bstrVal);</span>
<span class="rem">                        ///////////////////////////////////</span>
<span class="rem">                        ///// check to see if the value returned is a hexadecimal number</span>
<span class="rem">                        ///// or a color code number</span>
<span class="rem">                        theVisio-&gt;gdVisible = 1;</span>
<span class="rem">                        if(RGBVal[0] == '#') </span>
<span class="rem">                        {</span>
<span class="rem">                            const char hexChars[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};</span>
<span class="rem">                            val1 = RGBVal[1];</span>
<span class="rem">                            val2 = RGBVal[2];</span>
<span class="rem">                            val3 = RGBVal[3];</span>
<span class="rem">                            val4 = RGBVal[4];</span>
<span class="rem">                            val5 = RGBVal[5];</span>
<span class="rem">                            val6 = RGBVal[6];</span>
<span class="rem">                            int red,green,blue;</span>
<span class="rem">                            red = 0;</span>
<span class="rem">                            green = 0;</span>
<span class="rem">                            blue = 0;</span>
<span class="rem">                            for(valNum = 0;valNum &lt; 16;valNum++)</span>
<span class="rem">                            {</span>
<span class="rem">                                if(val1 == RGBVal[valNum])</span>
<span class="rem">                                    red = red + (valNum * 16);</span>
<span class="rem">                                </span>
<span class="rem"></span>
<span class="rem">                                if(val3 == RGBVal[valNum])</span>
<span class="rem">                                    green = valNum * 16;</span>
<span class="rem">                                </span>
<span class="rem"></span>
<span class="rem">                                if(val5 == RGBVal[valNum])</span>
<span class="rem">                                    blue = valNum * 16;</span>
<span class="rem">                                </span>
<span class="rem">                            }    // end for</span>
<span class="rem"></span>
<span class="rem">                            for(valNum = 0;valNum &lt; 16;valNum++)</span>
<span class="rem">                            {</span>
<span class="rem">                                if(val2 == RGBVal[valNum])</span>
<span class="rem">                                    theVisio-&gt;gdRed = red + valNum;</span>
<span class="rem"></span>
<span class="rem">                                if(val4 == RGBVal[valNum])</span>
<span class="rem">                                    theVisio-&gt;gdGreen = green + valNum;</span>
<span class="rem"></span>
<span class="rem">                                if(val6 == RGBVal[valNum])</span>
<span class="rem">                                    theVisio-&gt;gdBlue = blue + valNum;</span>
<span class="rem">                            }    // end for</span>
<span class="rem"></span>
<span class="rem"></span>
<span class="rem">                        }    // end if(RGBVal[0] == '#') </span>
<span class="rem">                        if(RGBVal[0] != '#')</span>
<span class="rem">                        {</span>
<span class="rem">                            int value;</span>
<span class="rem">                            value = int(RGBVal[0]);</span>
<span class="rem">                            switch(value)</span>
<span class="rem">                            {</span>
<span class="rem">                                case 0 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 0;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 0;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 0;</span>
<span class="rem">                                    theVisio-&gt;gdVisible = 0;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 1 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 255;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 255;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 255;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 2 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 255;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 0;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 0;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 3 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 0;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 255;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 0;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 4 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 0;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 0;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 255;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 5 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 255;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 255;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 0;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 6 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 255;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 0;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 255;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 7 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 0;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 255;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 255;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 8 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 128;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 0;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 0;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 9 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 0;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 128;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 0;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 10 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 0;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 0;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 128;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 11 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 128;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 128;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 0;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 12 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 128;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 0;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 128;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 13 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 0;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 128;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 128;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 14 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 192;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 192;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 192;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 15 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 230;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 230;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 230;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 16 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 205;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 205;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 205;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 17 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 179;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 179;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 179;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 18 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 154;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 154;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 154;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 19 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 128;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 128;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 128;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 20 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 102;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 102;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 102;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 21 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 77;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 77;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 77;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 22 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 51;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 51;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 51;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                case 23 :</span>
<span class="rem">                                    theVisio-&gt;gdRed = 26;</span>
<span class="rem">                                    theVisio-&gt;gdGreen = 26;</span>
<span class="rem">                                    theVisio-&gt;gdBlue = 26;</span>
<span class="rem">                                    break;</span>
<span class="rem">                                default: break;</span>
<span class="rem">                            }    // end switch</span>
<span class="rem">                        }// end if(RGBVal[0] != '#')</span>
<span class="rem">                    } // end if((theVisio-&gt;pChild = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t("//Shape/Line/LineColor"))) != NULL)</span>
<span class="rem">                    else</span>
<span class="rem">                        theVisio-&gt;gdVisible = 0;</span>
<span class="rem">                    </span>
<span class="rem">                    // add logic to include the rect values in list</span>
<span class="rem"></span>
<span class="rem">                    shapes.Easting0 = theVisio-&gt;gdXRect0;</span>
<span class="rem">                    shapes.Northing0 = theVisio-&gt;gdYRect0;</span>
<span class="rem">                    shapes.Altitude0 = theVisio-&gt;gdZRect0;</span>
<span class="rem">                    </span>
<span class="rem">                    shapes.Easting1 = theVisio-&gt;gdXRect1;</span>
<span class="rem">                    shapes.Northing1 = theVisio-&gt;gdYRect1;</span>
<span class="rem">                    shapes.Altitude1 = theVisio-&gt;gdZRect1;</span>
<span class="rem"></span>
<span class="rem">                    shapes.Easting2 = theVisio-&gt;gdXRect2;</span>
<span class="rem">                    shapes.Northing2 = theVisio-&gt;gdYRect2;</span>
<span class="rem">                    shapes.Altitude2 = theVisio-&gt;gdZRect2;</span>
<span class="rem"></span>
<span class="rem">                    shapes.Easting3 = theVisio-&gt;gdXRect3;</span>
<span class="rem">                    shapes.Northing3 = theVisio-&gt;gdYRect3;</span>
<span class="rem">                    shapes.Altitude3 = theVisio-&gt;gdZRect3;</span>
<span class="rem"></span>
<span class="rem">                    shapes.lineWeight = theVisio-&gt;gdLineWeight;</span>
<span class="rem">                    shapes.visibility = theVisio-&gt;gdVisible;</span>
<span class="rem">                    shapes.red = theVisio-&gt;gdRed;</span>
<span class="rem">                    shapes.blue = theVisio-&gt;gdBlue;</span>
<span class="rem">                    shapes.green = theVisio-&gt;gdGreen;</span>
<span class="rem">                    shapes.alpha = 255;</span>
<span class="rem"></span>
<span class="rem">                    RectList.push_back(shapes);</span>
<span class="rem">                }// end if((theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodePtr-&gt;selectSingleNode(_bstr_t("//Shape[Geom][XForm/PinX][XForm/PinY][XForm/Width][XForm/Height]")) != NULL)    </span>
<span class="rem">                 </span>
<span class="rem">            }    // end for(int n = 0; n &lt; shapesCount; n++)    </span>
<span class="rem">            </span>
<span class="rem">                */</span>

                
            <span class="rem">// sort the list</span>
            <span class="rem">// Algorithm : the nearest neighbour search</span>
            <span class="rem">////////////////////////////////////////////////////////////////////////////</span>
            <span class="rem">/////////////////////////////////////////////////////////////////////////</span>
            <span class="rem">///////////////////////</span>

            <span class="kwrd">double</span> range,angle,prevrange,prevangle;
            <span class="kwrd">bool</span> greater = FALSE;
            <span class="kwrd">bool</span> equal = FALSE;
            <span class="kwrd">while</span>(!OutList.empty())
            {    

                fstListIter = OutList.begin();
                nxtListIter = OutList.begin();
                curListIter = OutList.begin();
        
        
                <span class="kwrd">if</span>(OutList.size() == 1)
                {
                    OutCheckedList.push_back(*fstListIter);
                    <span class="kwrd">if</span>(fstListIter != OutList.end())
                        OutList.erase(fstListIter);
                }
        
                <span class="kwrd">if</span>(OutList.size() == 2)
                {
                    ++nxtListIter;
                    OutCheckedList.push_back(*fstListIter);
                    OutCheckedList.push_back(*nxtListIter);
                    <span class="kwrd">if</span>(fstListIter != OutList.end())
                        OutList.erase(fstListIter);
                    <span class="kwrd">if</span>(nxtListIter != OutList.end())
                        OutList.erase(nxtListIter);
                }
        

                <span class="kwrd">if</span>(OutList.size() == 3)
                {
                    ++nxtListIter;
                    curListIter = nxtListIter;
                    ++curListIter;
                    first = *fstListIter;
                    next = *nxtListIter;
                    cur = *curListIter;

                    UTMPosition UTMPositionFirst(0,first.Northing,first.Easting);
                    UTMPosition UTMPositionNext(0,next.Northing,next.Easting);

                    UTMPositionFirst.angleTo(UTMPositionNext,angle,prevrange);

                    UTMPosition UTMPositionCur(0,cur.Northing,cur.Easting);
                    UTMPositionFirst.angleTo(UTMPositionCur,angle,range);
                    <span class="kwrd">if</span>(prevrange &gt; range)
                    {
                        <span class="rem">//cout &lt;&lt; "prevrange &gt; range out" &lt;&lt; endl;</span>
                        OutCheckedList.push_back(*fstListIter);
                        OutCheckedList.push_back(*curListIter);
                        OutCheckedList.push_back(*nxtListIter);
                        OutList.erase(fstListIter);
                        OutList.erase(nxtListIter);
                        OutList.erase(curListIter);
                        <span class="rem">//OutCheckedList.push_back(*curListIter);</span>
                        <span class="rem">//OutCheckedList.push_back(*nxtListIter);</span>
                    }
                    <span class="kwrd">else</span>
                    {
                        <span class="rem">//cout &lt;&lt; "prevrange &lt; range out" &lt;&lt; endl;</span>
                        OutCheckedList.push_back(*fstListIter);
                        OutCheckedList.push_back(*nxtListIter);
                        OutCheckedList.push_back(*curListIter);
                        OutList.erase(fstListIter);
                        OutList.erase(nxtListIter);
                        OutList.erase(curListIter);
                        
                    }
                    
                }



                <span class="kwrd">if</span>(OutList.size() &gt; 3)
                {
                    ++nxtListIter;
                    curListIter = nxtListIter;
                    ++curListIter;
                    first = *fstListIter;
                    next = *nxtListIter;
                    cur = *curListIter;

                    UTMPosition UTMPositionFirst(0,first.Northing,first.Easting);
                    UTMPosition UTMPositionNext(0,next.Northing,next.Easting);

                    UTMPositionFirst.angleTo(UTMPositionNext,angle,prevrange);

                    <span class="kwrd">for</span>(;curListIter != OutList.end();curListIter++)
                    {
                        cur = *curListIter;
                        UTMPosition UTMPositionCur(0,cur.Northing,cur.Easting);
                        UTMPositionFirst.angleTo(UTMPositionCur,angle,range);
                        
                        <span class="rem">// range to determine if it is greater or lesser than prevrange</span>
                        <span class="kwrd">if</span>(prevrange &gt; range)
                        {    
                            
                            prevrange = range;
                            tmpListIter = curListIter;
                            greater = TRUE;
                        }    <span class="rem">// end if(prevrange &gt; range)</span>
                        
                    }    <span class="rem">// end for(;curListIter != OutList.end();curListIter++)</span>
                    
                    
                    <span class="kwrd">if</span>(greater)
                    {
                        swap(*nxtListIter,*tmpListIter);
                        greater = FALSE;
                    }
                    
                    <span class="kwrd">if</span>(!greater)
                    {
                        OutCheckedList.push_back(*fstListIter);
                        <span class="kwrd">if</span>(fstListIter != OutList.end())
                            OutList.erase(fstListIter);        
                    }
                    
                }    <span class="rem">// end if(OutList.size() &gt; 3)</span>
                
            }    <span class="rem">// end while(!OutList.empty())</span>
        
            <span class="rem">////////////////////////////////////////////////////////////////</span>

            <span class="rem">// sort the InList(inside of the track)</span>
            greater = FALSE;
            <span class="kwrd">while</span>(!InList.empty())
            {
                fstListIter = InList.begin();
                nxtListIter = InList.begin();
                curListIter = InList.begin();

                <span class="kwrd">if</span>(InList.size() == 1)
                {
                    InCheckedList.push_back(*fstListIter);
                    <span class="kwrd">if</span>(fstListIter != InList.end())
                        InList.erase(fstListIter);
                }

                
                <span class="kwrd">if</span>(InList.size() == 2)
                {
                    ++nxtListIter;
                    InCheckedList.push_back(*fstListIter);
                    InCheckedList.push_back(*nxtListIter);
                    <span class="kwrd">if</span>(fstListIter != InList.end())
                        InList.erase(fstListIter);
                    <span class="kwrd">if</span>(nxtListIter != InList.end())
                        InList.erase(nxtListIter);
                }
                

                <span class="kwrd">if</span>(InList.size() == 3)
                {
                    ++nxtListIter;
                    curListIter = nxtListIter;
                    ++curListIter;
                    first = *fstListIter;    <span class="rem">// first point</span>
                    next = *nxtListIter;    <span class="rem">// second point</span>
                    cur = *curListIter;        <span class="rem">// third point</span>

                    UTMPosition UTMPositionFirst(0,first.Northing,first.Easting);
                    UTMPosition UTMPositionNext(0,next.Northing,next.Easting);

                    UTMPositionFirst.angleTo(UTMPositionNext,angle,prevrange);

                    UTMPosition UTMPositionCur(0,cur.Northing,cur.Easting);
                    UTMPositionFirst.angleTo(UTMPositionCur,angle,range);
                    <span class="kwrd">if</span>(prevrange &gt; range)
                    {
                        <span class="rem">//cout &lt;&lt; "prevrange &gt; range in " &lt;&lt; endl;</span>
                        InCheckedList.push_back(*fstListIter);
                        InCheckedList.push_back(*curListIter);
                        InCheckedList.push_back(*nxtListIter);
                        InList.erase(fstListIter);
                        InList.erase(nxtListIter);
                        InList.erase(curListIter);
                        
                    }
                    <span class="kwrd">else</span>
                    {
                        <span class="rem">//cout &lt;&lt; "prevrange &lt; range in" &lt;&lt; endl;</span>
                        InCheckedList.push_back(*fstListIter);
                        InCheckedList.push_back(*nxtListIter);
                        InCheckedList.push_back(*curListIter);
                        InList.erase(fstListIter);
                        InList.erase(nxtListIter);
                        InList.erase(curListIter);
                    }
                    
                    
                }

                <span class="kwrd">if</span>(InList.size() &gt; 3)
                {
                    ++nxtListIter;
                    curListIter = nxtListIter;
                    ++curListIter;
                    first = *fstListIter;
                    next = *nxtListIter;
                    cur = *curListIter;

                    UTMPosition UTMPositionFirst(0,first.Northing,first.Easting);
                    UTMPosition UTMPositionNext(0,next.Northing,next.Easting);

                    UTMPositionFirst.angleTo(UTMPositionNext,angle,prevrange);
         
                    <span class="kwrd">for</span>(;curListIter != InList.end();curListIter++)
                    {
                        cur = *curListIter;
                        UTMPosition UTMPositionCur(0,cur.Northing,cur.Easting);
                        UTMPositionFirst.angleTo(UTMPositionCur,angle,range);
                    
                        <span class="rem">// range to determine if it is greater or lesser than prevrange</span>
                        <span class="kwrd">if</span>(prevrange &gt; range)
                        {
                            prevrange = range;
                            tmpListIter = curListIter;
                            greater = TRUE;    
                        }    <span class="rem">// end if(prevrange &gt; range)</span>
                        

                    }    <span class="rem">// end for(;curListIter != InList.end();curListIter++)</span>

                    
                    <span class="kwrd">if</span>(greater)
                    {
                        swap(*nxtListIter,*tmpListIter);
                        greater = FALSE;
                    }
                    <span class="kwrd">if</span>(!greater)
                    {
                        InCheckedList.push_back(*fstListIter);
                        <span class="kwrd">if</span>(fstListIter != InList.end())
                            InList.erase(fstListIter);
                    }
                }    <span class="rem">//    end if(InList.size() &gt;= 3)</span>
            }    <span class="rem">// end while(!InList.empty())</span>

            <span class="rem">/////////////////////////////////////////////////////////////////////</span>
            <span class="rem">////////////////////////////////////////////////////////////////////</span>
            <span class="rem">// sort the FullInList(the new fullinside of the track)'</span>
            <span class="rem">// the new fullinside layer of the track is good only if </span>
            <span class="rem">// there is a fullinside layer</span>
            <span class="rem">// else the inside layer will be the default</span>

            
            greater = FALSE;
            <span class="kwrd">while</span>(!FullInList.empty())
            {
                fstListIter = FullInList.begin();
                nxtListIter = FullInList.begin();
                curListIter = FullInList.begin();

                <span class="kwrd">if</span>(FullInList.size() == 1)
                {
                    FullInCheckedList.push_back(*fstListIter);
                    <span class="kwrd">if</span>(fstListIter != FullInList.end())
                        FullInList.erase(fstListIter);
                }

                
                <span class="kwrd">if</span>(FullInList.size() == 2)
                {
                    ++nxtListIter;
                    FullInCheckedList.push_back(*fstListIter);
                    FullInCheckedList.push_back(*nxtListIter);
                    <span class="kwrd">if</span>(fstListIter != FullInList.end())
                        FullInList.erase(fstListIter);
                    <span class="kwrd">if</span>(nxtListIter != FullInList.end())
                        FullInList.erase(nxtListIter);
                }
                

                <span class="kwrd">if</span>(FullInList.size() == 3)
                {
                    ++nxtListIter;
                    curListIter = nxtListIter;
                    ++curListIter;
                    first = *fstListIter;    <span class="rem">// first point</span>
                    next = *nxtListIter;    <span class="rem">// second point</span>
                    cur = *curListIter;        <span class="rem">// third point</span>

                    UTMPosition UTMPositionFirst(0,first.Northing,first.Easting);
                    UTMPosition UTMPositionNext(0,next.Northing,next.Easting);

                    UTMPositionFirst.angleTo(UTMPositionNext,angle,prevrange);

                    UTMPosition UTMPositionCur(0,cur.Northing,cur.Easting);
                    UTMPositionFirst.angleTo(UTMPositionCur,angle,range);
                    <span class="kwrd">if</span>(prevrange &gt; range)
                    {
                        <span class="rem">//cout &lt;&lt; "prevrange &gt; range in " &lt;&lt; endl;</span>
                        FullInCheckedList.push_back(*fstListIter);
                        FullInCheckedList.push_back(*curListIter);
                        FullInCheckedList.push_back(*nxtListIter);
                        FullInList.erase(fstListIter);
                        FullInList.erase(nxtListIter);
                        FullInList.erase(curListIter);
                        
                    }
                    <span class="kwrd">else</span>
                    {
                        <span class="rem">//cout &lt;&lt; "prevrange &lt; range in" &lt;&lt; endl;</span>
                        FullInCheckedList.push_back(*fstListIter);
                        FullInCheckedList.push_back(*nxtListIter);
                        FullInCheckedList.push_back(*curListIter);
                        FullInList.erase(fstListIter);
                        FullInList.erase(nxtListIter);
                        FullInList.erase(curListIter);
                    }
                    
                    
                }

                <span class="kwrd">if</span>(FullInList.size() &gt; 3)
                {
                    ++nxtListIter;
                    curListIter = nxtListIter;
                    ++curListIter;
                    first = *fstListIter;
                    next = *nxtListIter;
                    cur = *curListIter;

                    UTMPosition UTMPositionFirst(0,first.Northing,first.Easting);
                    UTMPosition UTMPositionNext(0,next.Northing,next.Easting);

                    UTMPositionFirst.angleTo(UTMPositionNext,angle,prevrange);
         
                    <span class="kwrd">for</span>(;curListIter != FullInList.end();curListIter++)
                    {
                        cur = *curListIter;
                        UTMPosition UTMPositionCur(0,cur.Northing,cur.Easting);
                        UTMPositionFirst.angleTo(UTMPositionCur,angle,range);
                    
                        <span class="rem">// range to determine if it is greater or lesser than prevrange</span>
                        <span class="kwrd">if</span>(prevrange &gt; range)
                        {
                            prevrange = range;
                            tmpListIter = curListIter;
                            greater = TRUE;    
                        }    <span class="rem">// end if(prevrange &gt; range)</span>
                        

                    }    <span class="rem">// end for(;curListIter != FullInList.end();curListIter++)</span>

                    
                    <span class="kwrd">if</span>(greater)
                    {
                        swap(*nxtListIter,*tmpListIter);
                        greater = FALSE;
                    }
                    <span class="kwrd">if</span>(!greater)
                    {
                        FullInCheckedList.push_back(*fstListIter);
                        <span class="kwrd">if</span>(fstListIter != FullInList.end())
                            FullInList.erase(fstListIter);
                    }
                }    <span class="rem">//    end if(FullInList.size() &gt;= 3)</span>
            }    <span class="rem">// end while(!FullInList.empty())</span>


            <span class="rem">//////////////////////////////////////////////////////////////////////</span>
            <span class="rem">///////////////////////////////////</span>
            <span class="rem">// sort the PitInList</span>

    
            greater = FALSE;
            <span class="kwrd">while</span>(!PitInList.empty())
            {
                
                fstListIter = PitInList.begin();
                nxtListIter = PitInList.begin();
                curListIter = PitInList.begin();

                <span class="kwrd">if</span>(PitInList.size() == 1)
                {
                    PitInCheckedList.push_back(*fstListIter);
                    <span class="kwrd">if</span>(fstListIter != PitInList.end())
                        PitInList.erase(fstListIter);
                }

                
                <span class="kwrd">if</span>(PitInList.size() == 2)
                {
                    ++nxtListIter;
                    PitInCheckedList.push_back(*fstListIter);
                    PitInCheckedList.push_back(*nxtListIter);
                    <span class="kwrd">if</span>(fstListIter != PitInList.end())
                        PitInList.erase(fstListIter);
                    <span class="kwrd">if</span>(nxtListIter != PitInList.end())
                        PitInList.erase(nxtListIter);
                }
                

                <span class="kwrd">if</span>(PitInList.size() == 3)
                {
                    ++nxtListIter;
                    curListIter = nxtListIter;
                    ++curListIter;
                    first = *fstListIter;    <span class="rem">// first point</span>
                    next = *nxtListIter;    <span class="rem">// second point</span>
                    cur = *curListIter;        <span class="rem">// third point</span>

                    UTMPosition UTMPositionFirst(0,first.Northing,first.Easting);
                    UTMPosition UTMPositionNext(0,next.Northing,next.Easting);

                    UTMPositionFirst.angleTo(UTMPositionNext,angle,prevrange);

                    UTMPosition UTMPositionCur(0,cur.Northing,cur.Easting);
                    UTMPositionFirst.angleTo(UTMPositionCur,angle,range);
                    <span class="kwrd">if</span>(prevrange &gt; range)
                    {
                        <span class="rem">//cout &lt;&lt; "prevrange &gt; range pitin " &lt;&lt; endl;</span>
                        PitInCheckedList.push_back(*fstListIter);
                        PitInCheckedList.push_back(*curListIter);
                        PitInCheckedList.push_back(*nxtListIter);
                        
                    }
                    <span class="kwrd">else</span>
                    {
                        <span class="rem">//cout &lt;&lt; "prevrange &lt; range pitin" &lt;&lt; endl;</span>
                        PitInCheckedList.push_back(*fstListIter);
                        PitInCheckedList.push_back(*nxtListIter);
                        PitInCheckedList.push_back(*curListIter);
                    }
                    PitInList.erase(fstListIter);
                    PitInList.erase(nxtListIter);
                    PitInList.erase(curListIter);    
                    
                }

                <span class="kwrd">if</span>(PitInList.size() &gt; 3)
                {
                    ++nxtListIter;
                    curListIter = nxtListIter;
                    ++curListIter;
                    first = *fstListIter;
                    next = *nxtListIter;
                    cur = *curListIter;

                    UTMPosition UTMPositionFirst(0,first.Northing,first.Easting);
                    UTMPosition UTMPositionNext(0,next.Northing,next.Easting);

                    UTMPositionFirst.angleTo(UTMPositionNext,angle,prevrange);
         
                    <span class="kwrd">for</span>(;curListIter != PitInList.end();curListIter++)
                    {
                        cur = *curListIter;
                        UTMPosition UTMPositionCur(0,cur.Northing,cur.Easting);
                        UTMPositionFirst.angleTo(UTMPositionCur,angle,range);
                    
                        <span class="rem">// range to determine if it is greater or lesser than prevrange</span>
                        <span class="kwrd">if</span>(prevrange &gt; range)
                        {
                            
                            prevrange = range;
                            tmpListIter = curListIter;
                            greater = TRUE;    
                        }
                    }    <span class="rem">// end for(;curListIter != PitInList.end();curListIter++)</span>

                    
                    <span class="kwrd">if</span>(greater)
                    {
                        swap(*nxtListIter,*tmpListIter);
                        greater = FALSE;
                    }
                    <span class="kwrd">if</span>(!greater)
                    {
                        PitInCheckedList.push_back(*fstListIter);
                        <span class="kwrd">if</span>(fstListIter != PitInList.end())
                            PitInList.erase(fstListIter);
                    }
                }    <span class="rem">//    end if(PitInList.size() &gt;= 3)</span>
            }    <span class="rem">// end while(!PitInList.empty())</span>

            
            <span class="rem">//////////////////////////////////////////////////////////////////////</span>
            <span class="rem">///////////////////////////////////</span>
            <span class="rem">// sort the Island1List</span>

    
            greater = FALSE;
            <span class="kwrd">while</span>(!Island1List.empty())
            {
                
                fstListIter = Island1List.begin();
                nxtListIter = Island1List.begin();
                curListIter = Island1List.begin();

                <span class="kwrd">if</span>(Island1List.size() == 1)
                {
                    Island1CheckedList.push_back(*fstListIter);
                    <span class="kwrd">if</span>(fstListIter != Island1List.end())
                        Island1List.erase(fstListIter);
                }

                
                <span class="kwrd">if</span>(Island1List.size() == 2)
                {
                    ++nxtListIter;
                    Island1CheckedList.push_back(*fstListIter);
                    Island1CheckedList.push_back(*nxtListIter);
                    <span class="kwrd">if</span>(fstListIter != Island1List.end())
                        Island1List.erase(fstListIter);
                    <span class="kwrd">if</span>(nxtListIter != Island1List.end())
                        Island1List.erase(nxtListIter);
                }
                

                <span class="kwrd">if</span>(Island1List.size() == 3)
                {
                    ++nxtListIter;
                    curListIter = nxtListIter;
                    ++curListIter;
                    first = *fstListIter;    <span class="rem">// first point</span>
                    next = *nxtListIter;    <span class="rem">// second point</span>
                    cur = *curListIter;        <span class="rem">// third point</span>

                    UTMPosition UTMPositionFirst(0,first.Northing,first.Easting);
                    UTMPosition UTMPositionNext(0,next.Northing,next.Easting);

                    UTMPositionFirst.angleTo(UTMPositionNext,angle,prevrange);

                    UTMPosition UTMPositionCur(0,cur.Northing,cur.Easting);
                    UTMPositionFirst.angleTo(UTMPositionCur,angle,range);
                    <span class="kwrd">if</span>(prevrange &gt; range)
                    {
                        <span class="rem">//cout &lt;&lt; "prevrange &gt; range pitin " &lt;&lt; endl;</span>
                        Island1CheckedList.push_back(*fstListIter);
                        Island1CheckedList.push_back(*curListIter);
                        Island1CheckedList.push_back(*nxtListIter);
                        
                    }
                    <span class="kwrd">else</span>
                    {
                        <span class="rem">//cout &lt;&lt; "prevrange &lt; range pitin" &lt;&lt; endl;</span>
                        Island1CheckedList.push_back(*fstListIter);
                        Island1CheckedList.push_back(*nxtListIter);
                        Island1CheckedList.push_back(*curListIter);
                    }
                    Island1List.erase(fstListIter);
                    Island1List.erase(nxtListIter);
                    Island1List.erase(curListIter);    
                    
                }

                <span class="kwrd">if</span>(Island1List.size() &gt; 3)
                {
                    ++nxtListIter;
                    curListIter = nxtListIter;
                    ++curListIter;
                    first = *fstListIter;
                    next = *nxtListIter;
                    cur = *curListIter;

                    UTMPosition UTMPositionFirst(0,first.Northing,first.Easting);
                    UTMPosition UTMPositionNext(0,next.Northing,next.Easting);

                    UTMPositionFirst.angleTo(UTMPositionNext,angle,prevrange);
         
                    <span class="kwrd">for</span>(;curListIter != Island1List.end();curListIter++)
                    {
                        cur = *curListIter;
                        UTMPosition UTMPositionCur(0,cur.Northing,cur.Easting);
                        UTMPositionFirst.angleTo(UTMPositionCur,angle,range);
                    
                        <span class="rem">// range to determine if it is greater or lesser than prevrange</span>
                        <span class="kwrd">if</span>(prevrange &gt; range)
                        {
                            
                            prevrange = range;
                            tmpListIter = curListIter;
                            greater = TRUE;    
                        }
                    }    <span class="rem">// end for(;curListIter != Island1List.end();curListIter++)</span>

                    
                    <span class="kwrd">if</span>(greater)
                    {
                        swap(*nxtListIter,*tmpListIter);
                        greater = FALSE;
                    }
                    <span class="kwrd">if</span>(!greater)
                    {
                        Island1CheckedList.push_back(*fstListIter);
                        <span class="kwrd">if</span>(fstListIter != Island1List.end())
                            Island1List.erase(fstListIter);
                    }
                }    <span class="rem">//    end if(Island1List.size() &gt;= 3)</span>
            }    <span class="rem">// end while(!Island1List.empty())</span>
            

            <span class="rem">/// </span>
            <span class="rem">// function to interpolate the track</span>
            <span class="rem">// this function rearranges the list interpolates the track</span>
            <span class="rem">// this function is used to show the appropriate altitude values</span>
            <span class="rem">// for the track</span>

            <span class="kwrd">if</span>(FullInCheckedList.size() &gt; 3)
                funcToInterpolateTrack(FullInCheckedList);
            funcToInterpolateTrack(OutCheckedList);
            funcToInterpolateTrack(InCheckedList);

            <span class="rem">// the funcToInterpolateTrack(list&lt;trackMapVals&gt; &amp;listName) joins the first element</span>
            <span class="rem">// of the list to the last</span>
            <span class="rem">// the Graphics Display program also does the same</span>
            <span class="rem">// in order to maintain a clear track.....</span>
            <span class="rem">// the last item from the list shall be removed</span>
            <span class="rem">// the item will be joined later while creating</span>
            <span class="rem">// the altitude.txt file</span>

            <span class="rem">// erase last element of OutCheckedList</span>
            tempIter = OutCheckedList.end();
            tempIter--;
            <span class="kwrd">if</span>(tempIter != OutCheckedList.end())
                OutCheckedList.erase(tempIter);

            <span class="rem">// erase last element of InCheckedList</span>
            tempIter = InCheckedList.end();
            tempIter--;
            <span class="kwrd">if</span>(tempIter != InCheckedList.end())
                InCheckedList.erase(tempIter);

            <span class="rem">// erase last element of FullInCheckedList</span>
            tempIter = FullInCheckedList.end();
            tempIter--;
            <span class="kwrd">if</span>(tempIter != FullInCheckedList.end())
                FullInCheckedList.erase(tempIter);


            
            <span class="rem">///////////////// after sorting join the first point to the last</span>
            <span class="rem">///////////// ////// the joining of first point to last  is not used</span>
            <span class="rem">//////</span>
            <span class="rem">/*</span>
<span class="rem">            if(OutCheckedList.size() &gt; 0)</span>
<span class="rem">            {</span>
<span class="rem">                fstListIter = OutCheckedList.begin();</span>
<span class="rem">                OutCheckedList.push_back(*fstListIter);</span>
<span class="rem">            }</span>
<span class="rem"></span>
<span class="rem">            if(InCheckedList.size() &gt; 0)</span>
<span class="rem">            {</span>
<span class="rem">                fstListIter = InCheckedList.begin();</span>
<span class="rem">                InCheckedList.push_back(*fstListIter);</span>
<span class="rem">            }</span>
<span class="rem"></span>
<span class="rem">            if(PitInCheckedList.size() &gt; 0)</span>
<span class="rem">            {</span>
<span class="rem">                fstListIter = PitInCheckedList.begin();</span>
<span class="rem">                PitInCheckedList.push_back(*fstListIter);</span>
<span class="rem">            }</span>
<span class="rem">            */</span>

            <span class="rem">////////////////////////////////////////</span>
            <span class="rem">///////////////////////////////</span>
            <span class="rem">// Check the sorted file for similar points</span>
            <span class="rem">/////////////////////////////////////</span>
            <span class="rem">/*</span>
<span class="rem">            for(OutCheckedListIter = OutCheckedList.begin();OutCheckedListIter != OutCheckedList.end();OutCheckedListIter++)</span>
<span class="rem">            {</span>
<span class="rem">                nxtListIter = OutCheckedListIter;</span>
<span class="rem">                ++nxtListIter;</span>
<span class="rem">                for(;nxtListIter != OutCheckedList.end();nxtListIter++)</span>
<span class="rem">                {    </span>
<span class="rem">                    first = *OutCheckedListIter;</span>
<span class="rem">                    next = *nxtListIter;</span>
<span class="rem"></span>
<span class="rem">                    if(first.Easting == next.Easting)</span>
<span class="rem">                    {</span>
<span class="rem">                        if(first.Northing == next.Northing)</span>
<span class="rem">                        {</span>
<span class="rem">                            if(nxtListIter != OutCheckedList.end())</span>
<span class="rem">                                OutCheckedList.erase(nxtListIter);</span>
<span class="rem">                        }</span>
<span class="rem">                    }        </span>
<span class="rem">                }</span>
<span class="rem">            }</span>
<span class="rem">            */</span>

            <span class="rem">/*</span>
<span class="rem">            /////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="rem">            /////////////////////////////////////////////////////////////////////</span>
<span class="rem">            /////////////////////////////////////////</span>
<span class="rem"></span>
<span class="rem">            ////////////////////////////////</span>
<span class="rem">            /////////////// Logic to incorporate the altitude////////////</span>
<span class="rem">            ////////////    separate project for altitude has been created "AltitudeTool"//////////////</span>
<span class="rem">            ////////////////////////////////</span>
<span class="rem">            ///////////////////////////////</span>
<span class="rem"></span>
<span class="rem">            /////////// </span>
<span class="rem">            //////// the idea is to take the floor value of each point and assign it to the grid</span>
<span class="rem"></span>
<span class="rem">            double leastEasting,leastNorthing,highestEasting,highestNorthing;</span>
<span class="rem"></span>
<span class="rem">    </span>
<span class="rem">            leastNorthing = 12000000.0;</span>
<span class="rem">            highestNorthing = 0.0;</span>
<span class="rem">            leastEasting = 12000000.0;</span>
<span class="rem">            highestEasting = 0.0;    </span>
<span class="rem">            for(OutCheckedListIter = OutCheckedList.begin();OutCheckedListIter != OutCheckedList.end();OutCheckedListIter++)</span>
<span class="rem">            {</span>
<span class="rem">                out = *OutCheckedListIter;</span>
<span class="rem">                if (out.Easting &lt; leastEasting) {</span>
<span class="rem">                    leastEasting = out.Easting;</span>
<span class="rem">                }</span>
<span class="rem"></span>
<span class="rem">                if (out.Easting &gt; highestEasting) {</span>
<span class="rem">                    highestEasting = out.Easting;</span>
<span class="rem">                }</span>
<span class="rem"></span>
<span class="rem">                if (out.Northing &gt; highestNorthing) {</span>
<span class="rem">                    highestNorthing = out.Northing;</span>
<span class="rem">                }</span>
<span class="rem"></span>
<span class="rem">                if (out.Northing &lt; leastNorthing) {</span>
<span class="rem">                    leastNorthing = out.Northing;</span>
<span class="rem">                }</span>
<span class="rem">            }</span>
<span class="rem">    </span>
<span class="rem">            //myAlt *altStruct;</span>
<span class="rem">            //altStruct = (myAlt *)malloc(sizeof(myAlt[abs(ceil(highestEasting)-floor(leastEasting))][abs(ceil(highestNorthing)- floor(leastNorthing))]));</span>
<span class="rem">            //myAlt altStruct[abs(ceil(highestEasting)-floor(leastEasting))][abs(ceil(highestNorthing)- floor(leastNorthing))];    </span>
<span class="rem">    </span>
<span class="rem">            CPaintDC dc(this);</span>
<span class="rem">            CDC *pDC = GetDC();</span>
<span class="rem">            RenderableCircle rcCurrent(pDC,RGB(255, 0, 0), (int) __max(2.0 , 4.0), RGB(0, 0, 0));</span>
<span class="rem">            BOOL FOUND;</span>
<span class="rem">            FOUND = FALSE;</span>
<span class="rem"></span>
<span class="rem">            while(!InList.empty())</span>
<span class="rem">                InList.clear();</span>
<span class="rem">            for(InCheckedListIter = InCheckedList.begin();InCheckedListIter != InCheckedList.end();InCheckedListIter++)</span>
<span class="rem">            {</span>
<span class="rem">        </span>
<span class="rem">                InList.push_back(*InCheckedListIter);</span>
<span class="rem">            }</span>
<span class="rem"></span>
<span class="rem">            while(!InList.empty())</span>
<span class="rem">            {</span>
<span class="rem">                InCheckedListIter = InList.begin();</span>
<span class="rem">                first = *InCheckedListIter;</span>
<span class="rem">                nxtListIter = InCheckedListIter;</span>
<span class="rem">                ++nxtListIter;</span>
<span class="rem">                if(nxtListIter != InList.end())</span>
<span class="rem">                    next = *nxtListIter;</span>
<span class="rem">                rcCurrent.render(pDC,first.Easting-leastEasting,first.Northing-leastNorthing);</span>
<span class="rem">                rcCurrent.render(pDC,next.Easting-leastEasting,next.Northing-leastNorthing);</span>
<span class="rem"></span>
<span class="rem"></span>
<span class="rem">                cur.Easting = (first.Easting+next.Easting)/2;</span>
<span class="rem">                cur.Northing = (first.Northing+next.Northing)/2;</span>
<span class="rem">                UTMPosition UTMPositionCur(0,cur.Northing,cur.Easting);</span>
<span class="rem"></span>
<span class="rem">                OutCheckedListIter = OutCheckedList.begin();</span>
<span class="rem">                tempMap = *OutCheckedListIter;</span>
<span class="rem">                UTMPosition UTMPositiontemp(0,tempMap.Northing,tempMap.Easting);</span>
<span class="rem">                UTMPositionCur.angleTo(UTMPositiontemp,angle,prevrange);</span>
<span class="rem">            </span>
<span class="rem">                curListIter = OutCheckedListIter;</span>
<span class="rem">                ++curListIter;</span>
<span class="rem">                while(curListIter != OutCheckedList.end())</span>
<span class="rem">                {</span>
<span class="rem">                    out = *curListIter;</span>
<span class="rem">                    UTMPosition UTMPositionPresent(0,out.Northing,out.Easting);</span>
<span class="rem">                    UTMPositionCur.angleTo(UTMPositionPresent,angle,range);</span>
<span class="rem">                    if(prevrange &gt; range)</span>
<span class="rem"></span>
<span class="rem">                    {</span>
<span class="rem">                        prevrange = range;</span>
<span class="rem">                        tmpListIter = curListIter;</span>
<span class="rem">                        FOUND = TRUE;</span>
<span class="rem">                    }</span>
<span class="rem">                    ++curListIter;</span>
<span class="rem">                }</span>
<span class="rem">                if(FOUND)</span>
<span class="rem">                {</span>
<span class="rem">                    in = *tmpListIter;</span>
<span class="rem">                    rcCurrent.render(pDC,in.Easting-leastEasting,in.Northing-leastNorthing);</span>
<span class="rem">                    pDC-&gt;MoveTo(first.Easting-leastEasting,first.Northing-leastNorthing);</span>
<span class="rem">                    pDC-&gt;LineTo(in.Easting-leastEasting,in.Northing-leastNorthing);</span>
<span class="rem">                    pDC-&gt;MoveTo(next.Easting-leastEasting,next.Northing-leastNorthing);</span>
<span class="rem">                    pDC-&gt;LineTo(in.Easting-leastEasting,in.Northing-leastNorthing);</span>
<span class="rem">                    </span>
<span class="rem">                    FOUND = FALSE;</span>
<span class="rem">                }</span>
<span class="rem">                </span>
<span class="rem">                else</span>
<span class="rem">                {</span>
<span class="rem">                    rcCurrent.render(pDC,tempMap.Easting-leastEasting,tempMap.Northing-leastNorthing);</span>
<span class="rem">                    pDC-&gt;MoveTo(first.Easting-leastEasting,first.Northing-leastNorthing);</span>
<span class="rem">                    pDC-&gt;LineTo(tempMap.Easting-leastEasting,tempMap.Northing-leastNorthing);</span>
<span class="rem">                    pDC-&gt;MoveTo(next.Easting-leastEasting,next.Northing-leastNorthing);</span>
<span class="rem">                    pDC-&gt;LineTo(tempMap.Easting-leastEasting,tempMap.Northing-leastNorthing);</span>
<span class="rem">                }</span>
<span class="rem">                </span>
<span class="rem"></span>
<span class="rem">                </span>
<span class="rem">                    InList.erase(InCheckedListIter);</span>
<span class="rem">                    </span>
<span class="rem">                    </span>
<span class="rem">                    </span>
<span class="rem">            }</span>
<span class="rem">            dc.BitBlt(0,0,50,50,pDC,0,0,SRCCOPY);</span>
<span class="rem">        */</span>

            <span class="rem">/*</span>
<span class="rem">            for(OutCheckedListIter = OutCheckedList.begin();OutCheckedListIter != OutCheckedList.end();OutCheckedListIter++)</span>
<span class="rem">            {    </span>
<span class="rem">                first = *OutCheckedListIter;</span>
<span class="rem">                nxtListIter = InCheckedList.begin();</span>
<span class="rem">                next = *nxtListIter;</span>
<span class="rem"></span>
<span class="rem">                rcCurrent.render(pDC,first.Easting-leastEasting,first.Northing-leastNorthing);</span>
<span class="rem">                rcCurrent.render(pDC,next.Easting-leastEasting,next.Northing-leastNorthing);</span>
<span class="rem"></span>
<span class="rem">                UTMPosition UTMPositionFirst(0,first.Northing,first.Easting);</span>
<span class="rem">                UTMPosition UTMPositionNext(0,next.Northing,next.Easting);</span>
<span class="rem"></span>
<span class="rem">                UTMPositionFirst.angleTo(UTMPositionNext,angle,prevrange);</span>
<span class="rem"></span>
<span class="rem">            </span>
<span class="rem">                ++nxtListIter;</span>
<span class="rem">                for(;nxtListIter != InCheckedList.end();nxtListIter++)</span>
<span class="rem">                {</span>
<span class="rem">                </span>
<span class="rem">                    cur = *nxtListIter;</span>
<span class="rem">                    rcCurrent.render(pDC,cur.Easting-leastEasting,cur.Northing-leastNorthing);</span>
<span class="rem">                    UTMPosition UTMPositionCur(0,cur.Northing,cur.Easting);</span>
<span class="rem">                </span>
<span class="rem">                    UTMPositionFirst.angleTo(UTMPositionCur,angle,range);</span>
<span class="rem">                    if(prevrange &gt; range)</span>
<span class="rem">                    {</span>
<span class="rem">                        prevrange = range;</span>
<span class="rem">                        tmpListIter = nxtListIter;</span>
<span class="rem">                        FOUND = TRUE;</span>
<span class="rem">                    }</span>
<span class="rem">                }</span>
<span class="rem"></span>
<span class="rem">                if(FOUND)</span>
<span class="rem">                {</span>
<span class="rem">                    next = *tmpListIter;</span>
<span class="rem">                }</span>
<span class="rem">            </span>
<span class="rem">                pDC-&gt;MoveTo(first.Easting-leastEasting,first.Northing-leastNorthing);</span>
<span class="rem">                pDC-&gt;LineTo(next.Easting-leastEasting,next.Northing-leastNorthing);</span>
<span class="rem">                FOUND = FALSE;</span>
<span class="rem">                //pDC-&gt;Draw3dRect(100,100,300,300,RGB(255,0,0),RGB(255,0,0));</span>
<span class="rem">        </span>
<span class="rem">                dc.BitBlt(0,0,50,50,pDC,0,0,SRCCOPY);</span>
<span class="rem">        </span>
<span class="rem">        </span>
<span class="rem">                //for(int i = 0; i &lt; 2;i++)</span>
<span class="rem">                //    OutCheckedListIter++;</span>
<span class="rem">        </span>
<span class="rem">        </span>
<span class="rem">            }</span>
<span class="rem">    </span>
<span class="rem">    </span>
<span class="rem">            */</span>

            

            <span class="rem">// Build the XML File //////////////////////////////////</span>

            <span class="rem">////////////////////////////////////////////////////</span>

            <span class="rem">// run diagnostics //////////////////</span>
        
            SUCCESS = VARIANT_TRUE;
            hr = S_OK;
            SUCCESS = theVisio-&gt;fillxmlOutValues(); <span class="rem">// This function creates </span>
                                                    <span class="rem">// the xmlformat to fill the necessary values.</span>
                                                    <span class="rem">// (other methods could be used but this was one of the solutions</span>

            <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">"Could not run fillxmlOutValues "</span>;

            <span class="kwrd">for</span>(OutCheckedListIter = OutCheckedList.begin();OutCheckedListIter != OutCheckedList.end();OutCheckedListIter++)
            {
                status = <span class="str">"... Building outsideTrackSegment..."</span>;
                m_status.SetWindowText(status);
                <span class="kwrd">out</span> = *OutCheckedListIter;
                theVisio-&gt;gdXOut = <span class="kwrd">out</span>.Easting;
                theVisio-&gt;gdYOut = <span class="kwrd">out</span>.Northing;
                theVisio-&gt;gdZOut = <span class="kwrd">out</span>.Altitude;
                progCtrl++;
                m_trackProgress.SetPos(progCtrl);

                theVisio-&gt;OGLDOMNodeListPtr = theVisio-&gt;OGLDOMDocumentPtr-&gt;getElementsByTagName(<span class="str">"trackOutsideSegment"</span>);
                theVisio-&gt;OGLDOMNodePtr = theVisio-&gt;OGLDOMNodeListPtr-&gt;item[0];

                SUCCESS = theVisio-&gt;BuildShape(theVisio-&gt;OGLDOMDocumentPtr,theVisio-&gt;OGLDOMNodePtr,theVisio-&gt;xmlOutValuesList);
                <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">" Problem creating the outside segment"</span>;

                
            }
            hr = theVisio-&gt;OGLDOMDocumentPtr-&gt;save(vName);    <span class="rem">// Save the file to be reloaded to add values</span>
            <span class="kwrd">if</span>(hr == S_FALSE) <span class="kwrd">throw</span> <span class="str">" Saving Outside segment failed"</span>;

            SUCCESS = VARIANT_TRUE;
            hr = S_OK;

            <span class="rem">//// run fillList</span>
            SUCCESS = theVisio-&gt;fillxmlInValues();
            <span class="kwrd">if</span>(SUCCESS = VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">"Could not run fillxmlInValues "</span>;

            
            <span class="kwrd">for</span>(InCheckedListIter = InCheckedList.begin();InCheckedListIter != InCheckedList.end();InCheckedListIter++)
            {
                status = <span class="str">"... Building insideTrackSegment..."</span>;
                m_status.SetWindowText(status);
                <span class="kwrd">in</span> = *InCheckedListIter;
                theVisio-&gt;gdXIn = <span class="kwrd">in</span>.Easting;
                theVisio-&gt;gdYIn = <span class="kwrd">in</span>.Northing;
                theVisio-&gt;gdZIn = <span class="kwrd">in</span>.Altitude;

                progCtrl++;
                m_trackProgress.SetPos(progCtrl);

                theVisio-&gt;OGLDOMNodeListPtr = theVisio-&gt;OGLDOMDocumentPtr-&gt;getElementsByTagName(<span class="str">"trackInsideSegment"</span>);
                theVisio-&gt;OGLDOMNodePtr = theVisio-&gt;OGLDOMNodeListPtr-&gt;item[0];
                    
                SUCCESS = theVisio-&gt;BuildShape(theVisio-&gt;OGLDOMDocumentPtr,theVisio-&gt;OGLDOMNodePtr,theVisio-&gt;xmlInValuesList);
                <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">" Problem creating the inside segment"</span>;
                
            }
            hr = theVisio-&gt;OGLDOMDocumentPtr-&gt;save(vName);    <span class="rem">// Save the file to be reloaded to add values</span>
            <span class="kwrd">if</span>(hr == S_FALSE) <span class="kwrd">throw</span> <span class="str">" Problem Saving Inside segment failed"</span>;

            
            SUCCESS = VARIANT_TRUE;
            hr = S_OK;
            <span class="rem">// run fillList</span>
            SUCCESS = theVisio-&gt;fillxmlPitInValues();
            <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">" Could not create fillxmlPitInValues"</span>;

            <span class="kwrd">for</span>(PitInCheckedListIter = PitInCheckedList.begin();PitInCheckedListIter != PitInCheckedList.end();PitInCheckedListIter++)
            {
                status = <span class="str">"... Building pitSegment..."</span>;
                m_status.SetWindowText(status);
                pitin = *PitInCheckedListIter;
                theVisio-&gt;gdXPitIn = pitin.Easting;
                theVisio-&gt;gdYPitIn = pitin.Northing;
                theVisio-&gt;gdZPitIn = pitin.Altitude;

                progCtrl++;
                m_trackProgress.SetPos(progCtrl);

                theVisio-&gt;OGLDOMNodeListPtr = theVisio-&gt;OGLDOMDocumentPtr-&gt;getElementsByTagName(<span class="str">"trackPitIn"</span>);
                theVisio-&gt;OGLDOMNodePtr = theVisio-&gt;OGLDOMNodeListPtr-&gt;item[0];
                    
                SUCCESS = theVisio-&gt;BuildShape(theVisio-&gt;OGLDOMDocumentPtr,theVisio-&gt;OGLDOMNodePtr,theVisio-&gt;xmlPitInValuesList);
                <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">" Problem building pit "</span>;
                    
                    
            }    <span class="rem">// end for(PitInCheckedListIter..................)</span>

            hr = theVisio-&gt;OGLDOMDocumentPtr-&gt;save(vName);    <span class="rem">// Save the file to be reloaded to add values</span>
            <span class="kwrd">if</span>(hr == S_FALSE) <span class="kwrd">throw</span> <span class="str">" Error Saving xml file "</span>;

            
            SUCCESS = VARIANT_TRUE;
            hr = S_OK;
            <span class="rem">// run fillList</span>
            SUCCESS = theVisio-&gt;fillxmlPitInValues();
            <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">" Could not create fillxmlPitInValues"</span>;

            <span class="kwrd">for</span>(Island1CheckedListIter = Island1CheckedList.begin();Island1CheckedListIter != Island1CheckedList.end();Island1CheckedListIter++)
            {
                status = <span class="str">"... Building island1Segment..."</span>;
                m_status.SetWindowText(status);
                pitin = *Island1CheckedListIter;
                theVisio-&gt;gdXPitIn = pitin.Easting;
                theVisio-&gt;gdYPitIn = pitin.Northing;
                theVisio-&gt;gdZPitIn = pitin.Altitude;

                progCtrl++;
                m_trackProgress.SetPos(progCtrl);

                theVisio-&gt;OGLDOMNodeListPtr = theVisio-&gt;OGLDOMDocumentPtr-&gt;getElementsByTagName(<span class="str">"trackPitIn"</span>);
                theVisio-&gt;OGLDOMNodePtr = theVisio-&gt;OGLDOMNodeListPtr-&gt;item[1];
                    
                SUCCESS = theVisio-&gt;BuildShape(theVisio-&gt;OGLDOMDocumentPtr,theVisio-&gt;OGLDOMNodePtr,theVisio-&gt;xmlPitInValuesList);
                <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">" Problem building island1 "</span>;
                    
                    
            }    <span class="rem">// end for(Island1CheckedListIter..................)</span>

            hr = theVisio-&gt;OGLDOMDocumentPtr-&gt;save(vName);    <span class="rem">// Save the file to be reloaded to add values</span>
            <span class="kwrd">if</span>(hr == S_FALSE) <span class="kwrd">throw</span> <span class="str">" Error Saving xml file "</span>;

            
            SUCCESS = VARIANT_TRUE;
            hr = S_OK;
            <span class="rem">///// run fillList</span>
            SUCCESS = theVisio-&gt;fillxmlStartStopValues();
            <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">" could not create xmlstartstopvalues"</span>;

            <span class="kwrd">for</span>(StartStopListIter = StartStopList.begin();StartStopListIter != StartStopList.end();StartStopListIter++)
            {
                status = <span class="str">"... Building startstop Line..."</span>;
                m_status.SetWindowText(status);
                    
                startstop = *StartStopListIter;
                trackMapVals refPoint,inPoint,outPoint;
                refPoint.Easting = startstop.BeginX;
                refPoint.Northing = startstop.BeginY;
                <span class="rem">//getClosestPoint(InCheckedList,refPoint,inPoint);</span>
                getClosestPoint(OutCheckedList,refPoint,outPoint);
                getClosestPoint(InCheckedList,refPoint,inPoint);
                <span class="rem">//</span>
                startstop.BeginZ = outPoint.Altitude;
                startstop.EndZ = inPoint.Altitude;
                theVisio-&gt;gdX = startstop.BeginX;
                theVisio-&gt;gdY = startstop.BeginY;
                theVisio-&gt;gdZ = startstop.BeginZ;
                theVisio-&gt;gdEndX = startstop.EndX;
                theVisio-&gt;gdEndY = startstop.EndY;
                theVisio-&gt;gdEndZ = startstop.EndZ;


                progCtrl++;
                m_trackProgress.SetPos(progCtrl);
                theVisio-&gt;OGLDOMNodeListPtr = theVisio-&gt;OGLDOMDocumentPtr-&gt;getElementsByTagName(<span class="str">"trackStartStopSegment"</span>);
                theVisio-&gt;OGLDOMNodePtr = theVisio-&gt;OGLDOMNodeListPtr-&gt;item[0];
                
                
                SUCCESS = theVisio-&gt;BuildShape(theVisio-&gt;OGLDOMDocumentPtr,theVisio-&gt;OGLDOMNodePtr,theVisio-&gt;xmlStartStopList);
                <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">" Problem building startstop segment"</span>;
                
                
            }
            hr = theVisio-&gt;OGLDOMDocumentPtr-&gt;save(vName);    <span class="rem">// Save the file to be reloaded to add values</span>
            <span class="kwrd">if</span>(hr == S_FALSE) <span class="kwrd">throw</span> <span class="str">"Problem saving file "</span>;

            <span class="rem">////////////// Build the turn values</span>

            SUCCESS = VARIANT_TRUE;
            hr = S_OK;
            SUCCESS = theVisio-&gt;fillxmlTurnValues();<span class="rem">// This function creates </span>
                                                    <span class="rem">// the xmlformat to fill the necessary values.</span>
                                                    <span class="rem">// (other methods could be used but this was one of the solutions</span>

            <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">"Could not run fillxmlTurnValues "</span>;

            <span class="kwrd">for</span>(TurnNoListIter = TurnNoList.begin();TurnNoListIter != TurnNoList.end();TurnNoListIter++)
            {
                status = <span class="str">"... Building turnNos Segment..."</span>;
                m_status.SetWindowText(status);
                turn = *TurnNoListIter;
                theVisio-&gt;gdXTurn = turn.Easting;
                theVisio-&gt;gdYTurn = turn.Northing;
                theVisio-&gt;gdZTurn = turn.Altitude;
                theVisio-&gt;gdTurnNo = turn.Turnvalue;
                theVisio-&gt;gdFontType = turn.TurnfontType;
                theVisio-&gt;gdTurnAngle = turn.TurnAngle;
                progCtrl++;
                m_trackProgress.SetPos(progCtrl);
                    
                    
                theVisio-&gt;OGLDOMNodeListPtr = theVisio-&gt;OGLDOMDocumentPtr-&gt;getElementsByTagName(<span class="str">"turnNos"</span>);
                theVisio-&gt;OGLDOMNodePtr = theVisio-&gt;OGLDOMNodeListPtr-&gt;item[0];

                SUCCESS = theVisio-&gt;BuildShape(theVisio-&gt;OGLDOMDocumentPtr,theVisio-&gt;OGLDOMNodePtr,theVisio-&gt;xmlTurnValuesList);
                <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">" Problem creating the turn segment"</span>;

                    
            }
            hr = theVisio-&gt;OGLDOMDocumentPtr-&gt;save(vName);    <span class="rem">// Save the file to be reloaded to add values</span>
            <span class="kwrd">if</span>(hr == S_FALSE) <span class="kwrd">throw</span> <span class="str">" Saving turn Numbers failed"</span>;

            <span class="rem">// code to build speed traps</span>
            <span class="rem">// should be fairly simple</span>
            <span class="rem">// Initially we init COMPtrs to point to the SpeedTraps element</span>
            theVisio-&gt;initializePtrsToBuildSpeedTrap(vName);

            <span class="rem">// After intializing let us fill the zonestructure list</span>
            <span class="rem">///// run theVisio-&gt;fillxmlZoneStructureValues();</span>
            SUCCESS = theVisio-&gt;fillxmlSpeedTrapStructureValues();
            <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">" could not create xmlSpeedTrapStructureValues"</span>;

            <span class="kwrd">for</span>(speedtrapListIter = speedtrapList.begin();speedtrapListIter != speedtrapList.end();speedtrapListIter++)
            {
                status = <span class="str">"... Building speedtraps ..."</span>;
                m_status.SetWindowText(status);
                    
                speedtrap = *speedtrapListIter;
                theVisio-&gt;gdX = speedtrap.BeginX;
                theVisio-&gt;gdY = speedtrap.BeginY;
                theVisio-&gt;gdZ = speedtrap.BeginZ;
                theVisio-&gt;gdEndX = speedtrap.EndX;
                theVisio-&gt;gdEndY = speedtrap.EndY;
                theVisio-&gt;gdEndZ = speedtrap.EndZ;
                theVisio-&gt;gdName = speedtrap.speedtrapName;
                progCtrl++;
                m_trackProgress.SetPos(progCtrl);
                    
                    
                SUCCESS = theVisio-&gt;BuildShape(theVisio-&gt;DOMDocumentPtr,theVisio-&gt;DOMNodePtr,theVisio-&gt;xmlSpeedTrapStructureList);
                <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">" Problem building Zone1 segment"</span>;
                
                    
            }    <span class="rem">// end for(speedtrapListIter = speedtrapList.begin();speedtrapListIter != speedtrapList.end();speedtrapListIter++)</span>
            hr = theVisio-&gt;DOMDocumentPtr-&gt;save(vName);    <span class="rem">// Save the file to be reloaded to add values</span>
            <span class="kwrd">if</span>(hr == S_FALSE) <span class="kwrd">throw</span> <span class="str">"Problem saving file "</span>;


            <span class="rem">// the new Zone structure will be used to fill both the In and Out</span>
            <span class="rem">// Zone Structure based on the condition that we do have an in and an out</span>
            <span class="rem">// for each zone if we do not possess an in and an out, we terminate</span>

            <span class="rem">// Initially we init COMPtrs to point to the Zones element</span>
            theVisio-&gt;initializePtrsToBuildZone(vName);

            <span class="rem">// After intializing let us fill the zonestructure list</span>
            <span class="rem">///// run theVisio-&gt;fillxmlZoneStructureValues();</span>
            SUCCESS = theVisio-&gt;fillxmlZoneStructureValues();
            <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">" could not create xmlZoneStructureValues"</span>;

            <span class="kwrd">for</span>(ZoneInListIter = ZoneInList.begin();ZoneInListIter != ZoneInList.end();ZoneInListIter++)
            {    <span class="rem">// </span>
                zonein = *ZoneInListIter;
                <span class="kwrd">for</span>(ZoneOutListIter = ZoneOutList.begin();ZoneOutListIter != ZoneOutList.end();ZoneOutListIter++)
                {
                    

                    zoneout = *ZoneOutListIter;
                    <span class="kwrd">if</span>(zonein.speedtrapName == zoneout.speedtrapName)
                    {
                        <span class="rem">// Check to see if the name matches and then build the file</span>

                        status = <span class="str">"... Building Zones..."</span>;
                        m_status.SetWindowText(status);

                        status = <span class="str">" Matching Zones Found ..."</span>;
                        m_status.SetWindowText(status);
                            
                        theVisio-&gt;gdZoneName = zonein.speedtrapName;
                        theVisio-&gt;gdXZoneIn1 = zonein.BeginX;
                        theVisio-&gt;gdYZoneIn1 = zonein.BeginY;
                        theVisio-&gt;gdZZoneIn1 = zonein.BeginZ;
                        progCtrl++;
                        m_trackProgress.SetPos(progCtrl);
                        theVisio-&gt;gdXZoneIn2 = zonein.EndX;
                        theVisio-&gt;gdYZoneIn2 = zonein.EndY;
                        theVisio-&gt;gdZZoneIn2 = zonein.EndZ;
                        progCtrl++;
                        m_trackProgress.SetPos(progCtrl);
                            
                            
                        theVisio-&gt;gdXZoneOut1 = zoneout.BeginX;
                        theVisio-&gt;gdYZoneOut1 = zoneout.BeginY;
                        theVisio-&gt;gdZZoneOut1 = zoneout.BeginZ;
                        progCtrl++;
                        m_trackProgress.SetPos(progCtrl);
                            
                        theVisio-&gt;gdXZoneOut2 = zoneout.EndX;
                        theVisio-&gt;gdYZoneOut2 = zoneout.EndY;
                        theVisio-&gt;gdZZoneOut2 = zoneout.EndZ;
                        progCtrl++;
                        m_trackProgress.SetPos(progCtrl);

                        SUCCESS = theVisio-&gt;BuildShape(theVisio-&gt;DOMDocumentPtr,theVisio-&gt;DOMNodePtr,theVisio-&gt;xmlZoneStructureList);
                        <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">" Problem building Zone1 segment"</span>;
                        

                    }    <span class="rem">// end if(zonein.speedtrapName == zoneout.speedtrapName)</span>
                }<span class="rem">// end for(ZoneOutListIter = ZoneOutList.begin();ZoneOutListIter != ZoneOutList.end();ZoneOutListIter++)</span>
            }<span class="rem">// end for(ZoneInListIter = ZoneInList.begin();ZoneInListIter != ZoneInList.end();ZoneInListIter++)</span>

            hr = theVisio-&gt;DOMDocumentPtr-&gt;save(vName);    <span class="rem">// Save the file to be reloaded to add values</span>
            <span class="kwrd">if</span>(hr == S_FALSE) <span class="kwrd">throw</span> <span class="str">"Problem saving file "</span>;

                
            status = <span class="str">".........Track File Complete..........."</span>;
            m_status.SetWindowText(status);

            <span class="kwrd">if</span>(AfxMessageBox(<span class="str">"Do you want to create the Altitude file ?"</span>,MB_YESNO | MB_ICONINFORMATION |MB_DEFBUTTON2) == IDYES)
            {    
                
            status = <span class="str">".........Building Altitude File Please Wait..........."</span>;
            m_status.SetWindowText(status);

            <span class="rem">/////////////// start altitude tool/////////////////////</span>
            <span class="rem">// The sorted list is used to build the altitude file</span>
            
            
            <span class="rem">// to create the region the list has to be</span>
            <span class="rem">// closed in other words.... the beginning of the list</span>
            <span class="rem">// should be joined to the end of the list</span>
            <span class="rem">// this forms a closed loop and helps in creating regions</span>
            <span class="rem">// </span>
            <span class="kwrd">if</span>(OutCheckedList.size() &gt; 3)
            {
                fstListIter = OutCheckedList.begin();
                OutCheckedList.push_back(*fstListIter);
            }
            <span class="kwrd">else</span>
            {
                AfxMessageBox(<span class="str">" Outside Segment of track has less than 3 elements, Please Check the selected file"</span>,MB_ICONSTOP,NULL);
                exit(0);
            }

            <span class="kwrd">if</span>(InCheckedList.size() &gt; 3)
            {
                fstListIter = InCheckedList.begin();
                InCheckedList.push_back(*fstListIter);
            }
            <span class="kwrd">else</span>
            {
                AfxMessageBox(<span class="str">" Inside Segment of track has less than 3 elements, Please Check the selected file"</span>,MB_ICONSTOP,NULL);
                exit(0);
            }


            
            <span class="kwrd">if</span>(FullInCheckedList.size() &gt; 3)
            {
                fstListIter = FullInCheckedList.begin();
                FullInCheckedList.push_back(*fstListIter);

                <span class="rem">// if fullinside layer exists and has </span>
                <span class="rem">// 3 or more points.........</span>
                <span class="rem">// we assume the fullinside to be the true inside</span>
                <span class="rem">// else we use the inside as the trueinside</span>
                InCheckedList.clear();
                <span class="kwrd">for</span>(FullInCheckedListIter = FullInCheckedList.begin();FullInCheckedListIter != FullInCheckedList.end();FullInCheckedListIter++)
                    InCheckedList.push_back(*FullInCheckedListIter);
            }
            

            <span class="kwrd">if</span>(PitInCheckedList.size() &gt; 0)    <span class="rem">// &gt;0 is to make sure there is a pit with some shapes</span>
            {
                fstListIter = PitInCheckedList.begin();
                PitInCheckedList.push_back(*fstListIter);
            }

            

            <span class="rem">// determine the min,max,Eastin and Northin</span>

            leastNorthing = 12000000.0;
            highestNorthing = 0.0;
            leastEasting = 12000000.0;
            highestEasting = 0.0;
            <span class="rem">// check minEasting , minNorthing, maxEasting and maxNorthing</span>
            <span class="kwrd">for</span>(OutCheckedListIter = OutCheckedList.begin();OutCheckedListIter != OutCheckedList.end();OutCheckedListIter++)
            {
                <span class="kwrd">out</span> = *OutCheckedListIter;
                <span class="kwrd">double</span> newEast = <span class="kwrd">out</span>.Easting;
                <span class="kwrd">double</span> newNorth = <span class="kwrd">out</span>.Northing;

                <span class="kwrd">if</span> (newEast &lt; leastEasting) {
                    leastEasting = newEast;
                }

                <span class="kwrd">if</span> (newEast &gt; highestEasting) {
                    highestEasting = newEast;
                }

                <span class="kwrd">if</span> (newNorth &gt; highestNorthing) {
                    highestNorthing = newNorth;
                }

                <span class="kwrd">if</span> (newNorth &lt; leastNorthing) {
                    leastNorthing = newNorth;
                }

            } <span class="rem">// end for(OutCheckedListIter = OutCheckedList.begin();OutCheckedListIter != OutCheckedList.end();OutCheckedListIter++)</span>

            
            <span class="rem">///////////////////////////////////////</span>
            <span class="rem">/// create the grid 1m X 1m based on the Easting and northing values</span>

            <span class="rem">// trackMapVals data structure for holding Easting,Northing,Altitude,etc</span>
            <span class="rem">//trackMapVals **z;    // **z is an array of pointers    </span>
                
            <span class="rem">/// colMax represents number of columns</span>
            <span class="rem">/// rowMax represents number of rows</span>
            colMax = abs(ceil(highestEasting) - floor(leastEasting)) + 4;
            rowMax = abs(ceil(highestNorthing) - floor(leastNorthing)) + 4;


            <span class="rem">///////////// Allocate pointers to array of pointers based on number of rows</span>
            <span class="rem">////////////// or based on the difference of maxNorthing and minNorthing</span>
            <span class="rem">///////////</span>
            <span class="kwrd">if</span>((trackGrid = (trackMapVals **) malloc(rowMax * <span class="kwrd">sizeof</span>(trackMapVals *))) == NULL)
                <span class="kwrd">throw</span> <span class="str">" Could not allocate memory "</span> ;

            <span class="rem">///////// if successful ////////////////</span>

            <span class="rem">////////// Allocate memory in rowwise order, i.e the first </span>
            <span class="rem">///////// pointer is an array to the first row ........ the second is pointer to second....</span>
            <span class="rem">///////// and so on till the maxRow is reached.......</span>
            <span class="rem">////////// throw exceptions after each rowwise allocation</span>

            <span class="kwrd">for</span>(<span class="kwrd">int</span> y = 0;y &lt; rowMax;y++)
            {
                <span class="rem">// malloc memory of 1 row each time</span>
                <span class="kwrd">if</span>((trackGrid[y] = (trackMapVals *) malloc(colMax * <span class="kwrd">sizeof</span>(trackMapVals))) == NULL)
                {
                    free(trackGrid);
                    <span class="kwrd">throw</span> <span class="str">" Could not allocate memory,Close some programs and try again"</span>;
                }
                
                <span class="rem">// fill the row x and y co-ordinates with respective Easting(x) and Northing(y) values</span>
                <span class="kwrd">for</span>(<span class="kwrd">int</span> x = 0;x &lt; colMax;x++)
                {
                    <span class="rem">/// poplulate the array in increment of 1m    </span>
                    tempMap.Easting = abs(floor(leastEasting)) + x - 2;
                    tempMap.Northing = abs(floor(leastNorthing)) + y - 2;
                    tempMap.Altitude = m_altitude;
                    tempMap.Filled = FALSE;
                    tempMap.InterPolated = FALSE;
                    trackGrid[y][x]= tempMap; <span class="rem">// tempMap is a struct object which has Easting,Northing,Altitude</span>
                    <span class="rem">//rcCurrent.render(pDC,x,y);            </span>
                }<span class="rem">// end for(int x = 0;x &lt; colMax;x++)</span>
            }<span class="rem">// end for(int y = 0;y &lt; rowMax;y++)</span>
            

            <span class="rem">// </span>
            <span class="rem">//////////////////////////////////////////////</span>
            <span class="rem">///////// modifications to the code based on </span>
            <span class="rem">//////// thompson track irregularity in altitude reporting</span>
            <span class="rem">////////////////////////////////////////////////</span>

            <span class="rem">///////////////////////////////////</span>
            <span class="rem">//////////////</span>
            <span class="rem">//// funcToInterpolateTrack(list);</span>
            <span class="rem">///// this function will take a list of points as a parameter and interpolate within the given list</span>
            <span class="rem">//////</span>
            <span class="rem">//funcToInterpolateTrack(FullInCheckedList);</span>
            <span class="rem">//funcToInterpolateTrack(OutCheckedList);</span>

            <span class="rem">///////// Determine the region :</span>
            <span class="rem">///////// the region is determined by taking two consecutive points on the inside of the track</span>
            <span class="rem">///////// the midpoint of the two point is then joined with</span>
            <span class="rem">/////////  the shortest distance on the outside. </span>
            <span class="rem">/////////  the two points on inside and one point on outside determine a triangular region</span>
                    
            BOOL FOUND;
            FOUND = FALSE;

            <span class="rem">/////// clear myCurRgnIn List</span>
            <span class="kwrd">if</span>(myCurRgnIn.empty() == FALSE)
                myCurRgnIn.clear();

            <span class="rem">////// clear myCurRgnOut List</span>
            <span class="kwrd">if</span>(myCurRgnOut.empty() == FALSE)
                myCurRgnOut.clear();

            <span class="rem">////// clear the inlist</span>
            <span class="kwrd">if</span>(InList.empty() == FALSE)
                InList.clear();

            <span class="rem">//////// fill the list with sorted points</span>
            <span class="kwrd">for</span>(InCheckedListIter = InCheckedList.begin();InCheckedListIter != InCheckedList.end();InCheckedListIter++)
            {
                cur = *InCheckedListIter;
                InList.push_back(cur);
            }

            <span class="rem">////////// iterate thru the list till empty</span>
                
            <span class="kwrd">while</span>(!InList.empty())
            {
                fstListIter = InList.begin();
                InListIter = InList.begin();
                    
                <span class="rem">// increment the Iterator to point to the second member of the list</span>
                <span class="kwrd">for</span>(<span class="kwrd">int</span> t = 0; t &lt; 1;t++)
                    ++InListIter;
                <span class="kwrd">if</span>(InList.size() == 1)
                {
                    InList.erase(fstListIter);
                }
                <span class="kwrd">if</span>(InList.size() &gt; 1)    <span class="rem">// if size &gt; 1</span>
                {
                    first = *fstListIter;    <span class="rem">// first point in sorted list</span>
                    next = *InListIter;    <span class="rem">// next point in sorted list</span>

                    <span class="rem">// mid point of the first and next</span>
                    <span class="kwrd">double</span> midEasting = (first.Easting + next.Easting)/2;
                    <span class="kwrd">double</span> midNorthing = (first.Northing + next.Northing)/2;
                    UTMPosition UTMPositionIn(0,midNorthing,midEasting);

                    curListIter = OutCheckedList.begin();
                    cur = *curListIter;
                    UTMPosition UTMPositionOut(0,cur.Northing,cur.Easting);

                    <span class="rem">// find distance between the mid inside point and first outside point</span>
                    UTMPositionIn.angleTo(UTMPositionOut,prevangle,prevrange);

                    <span class="kwrd">while</span>(curListIter != OutCheckedList.end())
                    {
                        ++curListIter;
                        cur = *curListIter;
                        
                        UTMPosition UTMPositionNextOut(0,cur.Northing,cur.Easting);
                        UTMPositionIn.angleTo(UTMPositionNextOut,angle,range);
                        <span class="kwrd">if</span>(prevrange &gt; range)
                        {    
                            prevrange = range;
                            tmpListIter = curListIter;
                            FOUND = TRUE;
                        } <span class="rem">// end if(prevrange &gt; range)</span>
                            

                    }    <span class="rem">// end while(curListIter != OutCheckedList.end())</span>
                        
                    <span class="kwrd">if</span>(!FOUND)
                    {
                        tmpListIter = OutCheckedList.begin();
                        tempMap = *tmpListIter;
                    }
                        
                    <span class="kwrd">if</span>(FOUND)
                    {
                        tempMap = *tmpListIter;
                        FOUND = FALSE;
                    }
                    <span class="rem">//////////// fill the list (set of 3 points)</span>
                    <span class="rem">//////////// in the order firstIn has the first inside point</span>
                    <span class="rem">////////////// secondIn has the next inside point</span>
                    <span class="rem">////////////// thirdOut has the outside track point</span>
                    curRgn.firstIn = first;
                    curRgn.secondIn = next;
                    curRgn.thirdOut = tempMap;
                    myCurRgnIn.push_back(curRgn);
                <span class="rem">//rcCurrent.render(pDC,tempMap.Easting-leastEasting,tempMap.Northing-leastNorthing);</span>
                <span class="rem">//rcCurrent.render(pDC,first.Easting-leastEasting,first.Northing-leastNorthing);</span>
                <span class="rem">//rcCurrent.render(pDC,next.Easting-leastEasting,next.Northing-leastNorthing);</span>
                <span class="rem">//pDC-&gt;MoveTo(tempMap.Easting-leastEasting,tempMap.Northing-leastNorthing);</span>
                <span class="rem">//pDC-&gt;LineTo(first.Easting-leastEasting,first.Northing-leastNorthing);</span>
                <span class="rem">//pDC-&gt;MoveTo(tempMap.Easting-leastEasting,tempMap.Northing-leastNorthing);</span>
                <span class="rem">//pDC-&gt;LineTo(next.Easting-leastEasting,next.Northing-leastNorthing);</span>
                <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
                    <span class="kwrd">if</span>(fstListIter != InList.end())
                        InList.erase(fstListIter);
                }    <span class="rem">// end else</span>
            }    <span class="rem">// end while(!InList.empty())</span>
            
            <span class="rem">////////////////////////////////////</span>
            <span class="rem">////////// join the first region to end of list</span>
            <span class="rem">//////// this is to determine the regions from outside to inside</span>
            <span class="rem">///////</span>
            <span class="kwrd">if</span>(myCurRgnIn.size() &gt; 0)
            {
                myCurRgnIter = myCurRgnIn.begin();
                myCurRgnIn.push_back(*myCurRgnIter);
            }

                
            <span class="rem">////////////// using the triangular vertices created </span>
            <span class="rem">////////////// from inside to outside , create triangular vertices</span>
            <span class="rem">/////////////  from outside to inside</span>
            <span class="kwrd">for</span>(myCurRgnIter = myCurRgnIn.begin();myCurRgnIter != myCurRgnIn.end();myCurRgnIter++)
            {
                Rgn thisRgn,nextRgn;
                myCurRgnIterNext = myCurRgnIter;
                <span class="rem">// increment the iterator to point to the next item in list</span>
                <span class="rem">//////// ++myCurRgnIterNext should work , but i found some problems</span>
                <span class="rem">////////</span>
                <span class="kwrd">for</span>(<span class="kwrd">int</span> a = 0; a &lt; 1;a++)
                    ++myCurRgnIterNext;
                    
                <span class="kwrd">if</span>(myCurRgnIterNext != myCurRgnIn.end())
                {
                    thisRgn = *myCurRgnIter;
                    nextRgn = *myCurRgnIterNext;
                    curRgn.firstIn = thisRgn.secondIn;
                    curRgn.secondIn = thisRgn.thirdOut;
                    curRgn.thirdOut = nextRgn.thirdOut;
                    myCurRgnOut.push_back(curRgn);
                }    <span class="rem">// end if(myCurRgnIterNext != myCurRgnIn.end())    </span>
            }    <span class="rem">// end for(myCurRgnIter = myCurRgnIn.begin();myCurRgnIter != myCurRgnIn.end();myCurRgnIter++)</span>
            
            <span class="rem">////////////////////////////////////////////</span>
            <span class="rem">//////// pass the myCurRgnIn list thru the grid to triangulate the grid</span>
            <span class="rem">/////////////////////////////////////</span>
            <span class="kwrd">for</span>(myCurRgnIter = myCurRgnIn.begin();myCurRgnIter != myCurRgnIn.end();myCurRgnIter++)
            {    
                Rgn newRgn;
                newRgn = *myCurRgnIter;
                    
                CPoint ptVertex[3];    <span class="rem">// holds the easting and northing points of a region</span>

                <span class="kwrd">double</span> x1,x2,x3,y1,y2,y3,z1,z2,z3;
                <span class="kwrd">int</span> myMinEast,myMaxEast,myMinNorth,myMaxNorth;
                x1 = ptVertex[0].x = newRgn.firstIn.Easting;
                y1 = ptVertex[0].y = newRgn.firstIn.Northing;
                z1 = newRgn.firstIn.Altitude;

                x2 = ptVertex[1].x = newRgn.secondIn.Easting;
                y2 = ptVertex[1].y = newRgn.secondIn.Northing;
                z2 = newRgn.secondIn.Altitude;

                x3 = ptVertex[2].x = newRgn.thirdOut.Easting;
                y3 = ptVertex[2].y = newRgn.thirdOut.Northing;
                z3 = newRgn.thirdOut.Altitude;
                    
                <span class="kwrd">if</span>(x1 &lt;= x2)
                {
                    myMinEast = abs(x1);
                    myMaxEast = abs(x2);
                }
                <span class="kwrd">else</span>
                {
                    myMinEast = abs(x2);
                    myMaxEast = abs(x1);
                }

                <span class="kwrd">if</span>(myMinEast &gt; x3)
                    myMinEast = abs(x3);
                <span class="kwrd">if</span>(myMaxEast &lt; x3)
                    myMaxEast = abs(x3);

                <span class="kwrd">if</span>(y1 &lt;= y2)
                {
                    myMinNorth = abs(y1);
                    myMaxNorth = abs(y2);
                }
                <span class="kwrd">else</span>
                {
                    myMinNorth = abs(y2);
                    myMaxNorth = abs(y1);
                }

                <span class="kwrd">if</span>(myMinNorth &gt; y3)
                    myMinNorth = abs(y3);
                <span class="kwrd">if</span>(myMaxNorth &lt; y3)
                    myMaxNorth = abs(y3);

                myMinEast =  myMinEast - leastEasting ;
                myMaxEast = myMaxEast - leastEasting + 4;
                myMinNorth = myMinNorth - leastNorthing;
                myMaxNorth = myMaxNorth - leastNorthing + 4;
                    
                <span class="kwrd">if</span>((rgnA.CreatePolygonRgn(ptVertex, 3, WINDING))== NULL)
                {
                    <span class="rem">/////////// Free the allocated memory rowwise</span>
                    <span class="kwrd">for</span>(<span class="kwrd">int</span> freeMe = 0;freeMe &lt; rowMax;freeMe++)
                    free(trackGrid[freeMe]);

                    <span class="rem">/// finally free the array of pointers.</span>
                    free(trackGrid);
                    <span class="kwrd">throw</span> <span class="str">" Could Not Create Region "</span>;
                }
                <span class="kwrd">double</span> A,B,C,D;

                A = y1*(z2 - z3) + y2*(z3 - z1) + y3*(z1 - z2);
                B = z1*(x2 - x3) + z2*(x3 - x1) + z3*(x1 - x2);
                C = x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2);
                D = -(x1*(y2*z3 - y3*z2) + x2*(y3*z1 - y1*z3) + x3*(y1*z2 - y2*z1));
                    
                <span class="kwrd">for</span>(<span class="kwrd">int</span> ky = myMinNorth;ky &lt; myMaxNorth;ky++)
                {
                    <span class="kwrd">for</span>(<span class="kwrd">int</span> kx = myMinEast;kx &lt; myMaxEast;kx++)
                    {
                        next = trackGrid[ky][kx];
                            
                        <span class="rem">/////////////////////////</span>
                        <span class="rem">//// determine if the point is in region</span>
                            
                        <span class="kwrd">if</span>(rgnA.PtInRegion(abs(next.Easting),abs(next.Northing)))
                        {
                                
                            next.Filled = TRUE;
                            next.Altitude = (-D -(A*next.Easting) -(B*next.Northing))/C;
                            <span class="kwrd">if</span>(next.Altitude &gt; 0)
                                next.InterPolated = TRUE;
                                trackGrid[ky][kx] = next;
                            <span class="rem">//rcCurrent.render(pDC,next.Easting-leastEasting,next.Northing-leastNorthing);</span>
                            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
                        }    <span class="rem">// end if(PtInRegion(rgnA,tempMap.Easting,tempMap.Northing))</span>
                            
                        <span class="rem">/*</span>
<span class="rem">                        if((floor(newRgn.firstIn.Easting) == tempMap.Easting) &amp;&amp; (floor(newRgn.firstIn.Northing) == tempMap.Northing))</span>
<span class="rem">                        {</span>
<span class="rem">                            tempMap.filled = TRUE;</span>
<span class="rem">                            trackGrid[ky][kx] = tempMap;</span>
<span class="rem">                            rcCurrent.render(pDC,tempMap.Easting-leastEasting,tempMap.Northing-leastNorthing);</span>
<span class="rem">                        }</span>
<span class="rem"></span>
<span class="rem">                        if((floor(newRgn.secondIn.Easting) == tempMap.Easting) &amp;&amp; (floor(newRgn.secondIn.Northing) == tempMap.Northing))</span>
<span class="rem">                        {</span>
<span class="rem">                            tempMap.filled = TRUE;</span>
<span class="rem">                            trackGrid[ky][kx] = tempMap;</span>
<span class="rem">                            rcCurrent.render(pDC,tempMap.Easting-leastEasting,tempMap.Northing-leastNorthing);</span>
<span class="rem">                        }</span>
<span class="rem"></span>
<span class="rem">                        if((floor(newRgn.thirdOut.Easting) == tempMap.Easting) &amp;&amp; (floor(newRgn.thirdOut.Northing) == tempMap.Northing))</span>
<span class="rem">                        {</span>
<span class="rem">                            tempMap.filled = TRUE;</span>
<span class="rem">                            trackGrid[ky][kx] = tempMap;</span>
<span class="rem">                            rcCurrent.render(pDC,tempMap.Easting-leastEasting,tempMap.Northing-leastNorthing);</span>
<span class="rem">                        }</span>
<span class="rem">                        */</span>
                                
                    }<span class="rem">// end for(int kx = 0;kx &lt; colMax;kx++)</span>
                }<span class="rem">// end for(int ky = 0;ky &lt; rowMax;ky++)</span>
                    
                <span class="rem">//// delete the previous region so a new one can be created</span>

                rgnA.DeleteObject();

            }    <span class="rem">// end for(myCurRgnIter = myCurRgnIn.begin();myCurRgnIter != myCurRgnIn.end();myCurRgnIter++)</span>
            
            <span class="kwrd">for</span>(myCurRgnIter = myCurRgnIn.begin();myCurRgnIter != myCurRgnIn.end();myCurRgnIter++)
            {
                Rgn newRgn;
                newRgn = *myCurRgnIter;
                <span class="kwrd">double</span> x1,x2,x3,y1,y2,y3,z1,z2,z3;
                x1 = newRgn.firstIn.Easting;
                y1 = newRgn.firstIn.Northing;
                z1 = newRgn.firstIn.Altitude;

                x2 = newRgn.secondIn.Easting;
                y2 = newRgn.secondIn.Northing;
                z2 = newRgn.secondIn.Altitude;

                x3 = newRgn.thirdOut.Easting;
                y3 = newRgn.thirdOut.Northing;
                z3 = newRgn.thirdOut.Altitude;
                    
                <span class="kwrd">double</span> A,B,C,D;

                A = y1*(z2 - z3) + y2*(z3 - z1) + y3*(z1 - z2);
                B = z1*(x2 - x3) + z2*(x3 - x1) + z3*(x1 - x2);
                C = x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2);
                D = -(x1*(y2*z3 - y3*z2) + x2*(y3*z1 - y1*z3) + x3*(y1*z2 - y2*z1));
                    
                <span class="rem">///////////////////////////////////////////////</span>
                <span class="rem">///////// fill the points adjacent to the line with </span>
                <span class="rem">///////// the bresneham algorithm and stretch 2 grid spaces</span>
                <span class="rem">//////// in all directions................</span>
                    
                <span class="rem">//modifiedlineFillAlgorithm(x1,y1,x2,y2,A,B,C,D);</span>
                <span class="rem">//modifiedlineFillAlgorithm(x2,y2,x3,y3,A,B,C,D);</span>
                <span class="rem">//modifiedlineFillAlgorithm(x3,y3,x1,y1,A,B,C,D);</span>
                    
                lineFillAlgorithm(x1,y1,x2,y2,A,B,C,D);
                lineFillAlgorithm(x2,y2,x3,y3,A,B,C,D);
                lineFillAlgorithm(x3,y3,x1,y1,A,B,C,D);
                    
            }    <span class="rem">// end for(myCurRgnIter = myCurRgnIn.begin();myCurRgnIter != myCurRgnIn.end();myCurRgnIter++)</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
                
                
            <span class="rem">/*    </span>
<span class="rem">            for(int kyy = 0; kyy &lt; rowMax; kyy++)</span>
<span class="rem">            {</span>
<span class="rem">                for(int kxx = 0; kxx &lt; colMax;kxx++)</span>
<span class="rem">                {</span>
<span class="rem">                    tempMap = trackGrid[kyy][kxx];</span>
<span class="rem">                    if((tempMap.InterPolated == FALSE)&amp;&amp; (tempMap.Filled == TRUE))</span>
<span class="rem">                    {</span>
<span class="rem">                        char buff[256];</span>
<span class="rem">                        sprintf(buff,"%f",tempMap.Altitude);</span>
<span class="rem">                        m_Easting.SetWindowText(buff);</span>
<span class="rem">                            </span>
<span class="rem">                        rcCurrent.render(pDC,tempMap.Easting-leastEasting,tempMap.Northing-leastNorthing);    </span>
<span class="rem">                        dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
<span class="rem">                    }</span>
<span class="rem">                }</span>
<span class="rem">            }</span>
<span class="rem">            */</span>

            <span class="rem">// open reg key </span>
            
            <span class="kwrd">if</span>(RegOpenKeyEx(HKEY_LOCAL_MACHINE,<span class="str">"Software\\Sumaria\\TrackTool"</span>,0,KEY_QUERY_VALUE,&amp;hKey) != ERROR_SUCCESS)
            {
                <span class="rem">/////////// Free the allocated memory rowwise</span>
                <span class="kwrd">for</span>(<span class="kwrd">int</span> freeMe = 0;freeMe &lt; rowMax;freeMe++)
                    free(trackGrid[freeMe]);

                <span class="rem">/// finally free the array of pointers.</span>
                free(trackGrid);
                <span class="kwrd">throw</span> <span class="str">" Failed to Open Registry "</span>;
            }
            dwBufLen = 255;
            <span class="kwrd">if</span>(RegQueryValueEx(hKey,_T(<span class="str">"InstallPath"</span>),NULL,NULL,(LPBYTE) szProductType,&amp;dwBufLen) != ERROR_SUCCESS)
            {
                <span class="rem">/////////// Free the allocated memory rowwise</span>
                <span class="kwrd">for</span>(<span class="kwrd">int</span> freeMe = 0;freeMe &lt; rowMax;freeMe++)
                    free(trackGrid[freeMe]);

                <span class="rem">/// finally free the array of pointers.</span>
                free(trackGrid);
                <span class="kwrd">throw</span> <span class="str">" Failed to Query Registry "</span>;
            }
            <span class="kwrd">if</span>(RegCloseKey(hKey) != ERROR_SUCCESS)
            {
                <span class="rem">/////////// Free the allocated memory rowwise</span>
                <span class="kwrd">for</span>(<span class="kwrd">int</span> freeMe = 0;freeMe &lt; rowMax;freeMe++)
                    free(trackGrid[freeMe]);

                <span class="rem">/// finally free the array of pointers.</span>
                free(trackGrid);
                <span class="kwrd">throw</span> <span class="str">" Failed to Close Registry "</span>;
            }

            status = szProductType;
            status.Append(<span class="str">"altData.txt"</span>);

            FILE *altDat;    <span class="rem">// file stream to open a file</span>
            <span class="kwrd">if</span>((altDat = fopen(status,<span class="str">"w+ | _O_CREAT"</span>)) == NULL)
            {
                <span class="rem">/////////// Free the allocated memory rowwise</span>
                <span class="kwrd">for</span>(<span class="kwrd">int</span> freeMe = 0;freeMe &lt; rowMax;freeMe++)
                    free(trackGrid[freeMe]);

                <span class="rem">/// finally free the array of pointers.</span>
                free(trackGrid);
                <span class="kwrd">throw</span> <span class="str">" Problem creating altData.txt file "</span>;
            }
            <span class="rem">// store the no of columns and no of rows</span>
            <span class="kwrd">if</span>((fprintf(altDat,<span class="str">"No of Columns = %u,No of Rows = %u\n"</span>,colMax,rowMax)) &lt; 0)
            {
                <span class="rem">/////////// Free the allocated memory rowwise</span>
                <span class="kwrd">for</span>(<span class="kwrd">int</span> freeMe = 0;freeMe &lt; rowMax;freeMe++)
                    free(trackGrid[freeMe]);

                <span class="rem">/// finally free the array of pointers.</span>
                free(trackGrid);
                <span class="kwrd">throw</span> <span class="str">"Error in  writing data to the file"</span>;
            }
            <span class="kwrd">if</span>((fprintf(altDat,<span class="str">"Northing,Easting,Altitude\n"</span>)) &lt; 0)
            {
                <span class="rem">/////////// Free the allocated memory rowwise</span>
                <span class="kwrd">for</span>(<span class="kwrd">int</span> freeMe = 0;freeMe &lt; rowMax;freeMe++)
                    free(trackGrid[freeMe]);

                <span class="rem">/// finally free the array of pointers.</span>
                free(trackGrid);
                <span class="kwrd">throw</span> <span class="str">"Error in  writing data to the file"</span>;
            }
            <span class="rem">/////////////////////////////////</span>
            <span class="rem">/// write the first element of the grid</span>
            tempMap = trackGrid[0][0];
            <span class="kwrd">if</span>((fprintf(altDat,<span class="str">"MinEasting = %f,MinNorthing = %f\n"</span>,tempMap.Easting,tempMap.Northing)) &lt; 0)
            {
                <span class="rem">/////////// Free the allocated memory rowwise</span>
                <span class="kwrd">for</span>(<span class="kwrd">int</span> freeMe = 0;freeMe &lt; rowMax;freeMe++)
                    free(trackGrid[freeMe]);

                <span class="rem">/// finally free the array of pointers.</span>
                free(trackGrid);
                <span class="kwrd">throw</span> <span class="str">"Error in  writing data to the file"</span>;
            }

            tempMap = trackGrid[rowMax - 1][colMax - 1];
            <span class="kwrd">if</span>((fprintf(altDat,<span class="str">"MaxEasting = %f,MaxNorthing = %f\n"</span>,tempMap.Easting,tempMap.Northing)) &lt; 0)
            {
                <span class="rem">/////////// Free the allocated memory rowwise</span>
                <span class="kwrd">for</span>(<span class="kwrd">int</span> freeMe = 0;freeMe &lt; rowMax;freeMe++)
                    free(trackGrid[freeMe]);

                <span class="rem">/// finally free the array of pointers.</span>
                free(trackGrid);
                <span class="kwrd">throw</span> <span class="str">"Error in  writing data to the file"</span>;
            }



            <span class="kwrd">for</span>(<span class="kwrd">int</span> kyy = 0; kyy &lt; rowMax; kyy++)
            {
                <span class="kwrd">for</span>(<span class="kwrd">int</span> kxx = 0; kxx &lt; colMax;kxx++)
                {
                    tempMap = trackGrid[kyy][kxx];
                    <span class="rem">//if((tempMap.Filled == TRUE) &amp;&amp; (tempMap.InterPolated == TRUE))</span>
                    <span class="kwrd">if</span>((fprintf(altDat,<span class="str">"%f,%f,%f\n"</span>,tempMap.Northing,tempMap.Easting,tempMap.Altitude)) &lt; 0)
                    {
                        <span class="rem">/////////// Free the allocated memory rowwise</span>
                        <span class="kwrd">for</span>(<span class="kwrd">int</span> freeMe = 0;freeMe &lt; rowMax;freeMe++)
                            free(trackGrid[freeMe]);

                        <span class="rem">/// finally free the array of pointers.</span>
                        free(trackGrid);
                        <span class="kwrd">throw</span> <span class="str">" Error in writing Grid data to file"</span>;
                    }    
                }
            }
            <span class="kwrd">if</span>((fclose(altDat)) == EOF)
            {
                <span class="rem">/////////// Free the allocated memory rowwise</span>
                <span class="kwrd">for</span>(<span class="kwrd">int</span> freeMe = 0;freeMe &lt; rowMax;freeMe++)
                    free(trackGrid[freeMe]);

                <span class="rem">/// finally free the array of pointers.</span>
                free(trackGrid);
                <span class="kwrd">throw</span> <span class="str">" Could not close the file altDat "</span>;
            }

                
            <span class="rem">/*</span>
<span class="rem"></span>
<span class="rem">            for(int kyy = 0; kyy &lt; rowMax; kyy++)</span>
<span class="rem">            {</span>
<span class="rem">                for(int kxx = 0; kxx &lt; colMax;kxx++)</span>
<span class="rem">                {</span>
<span class="rem">                    tempMap = trackGrid[kyy][kxx];</span>
<span class="rem">                    if(tempMap.InterPolated == TRUE)</span>
<span class="rem">                    {</span>
<span class="rem">                            OutCheckedList.push_back(tempMap);</span>
<span class="rem">                    }</span>
<span class="rem">                }</span>
<span class="rem">            }</span>
<span class="rem">            */</span>

            <span class="rem">/////////// Free the allocated memory rowwise</span>
            <span class="kwrd">for</span>(<span class="kwrd">int</span> freeMe = 0;freeMe &lt; rowMax;freeMe++)
                free(trackGrid[freeMe]);

            <span class="rem">/// finally free the array of pointers.</span>
            free(trackGrid);
            }    <span class="rem">// end if</span>
            <span class="rem">/////////////// end altitude tool/////////////////////</span>
            
            status = <span class="str">" .............Complete........."</span>;
            m_status.SetWindowText(status);
            ::SetCursor(m_hcurArrow);
            MessageBox(<span class="str">" The XML File is ready for use, THANK YOU "</span>);
            m_createXML.EnableWindow(TRUE);
            GetDlgItem(IDC_DATA_SOURCE_FILE)-&gt;EnableWindow(TRUE);
                
            m_trackProgress.SetPos(0);

        }    <span class="rem">// end try block</span>
        <span class="kwrd">catch</span>(<span class="kwrd">int</span> errThrow)
        {    
            status = <span class="str">"Error............."</span>;
            m_status.SetWindowText(status);
            
            <span class="kwrd">if</span>(errThrow == 1)
            {
                AfxMessageBox(<span class="str">" Unable to load the file, May be it is not the correct file"</span>,MB_OK);
                
                
                 <span class="rem">//OnBnClickedCreateXml();</span>
                <span class="kwrd">break</span>;
            }

            <span class="kwrd">if</span>(errThrow == 2) 
            {
                    MSXML2::IXMLDOMParseErrorPtr  pError;
                    pError = theVisio-&gt;DOMDocumentPtr-&gt;parseError;
                    _bstr_t parseError =_bstr_t(<span class="str">"At line "</span>)+ _bstr_t(pError-&gt;Getline()) + _bstr_t(<span class="str">"\n"</span>)+ _bstr_t(pError-&gt;Getreason());
                    em.MessageBox(parseError, <span class="str">"Check File again :  Load failed "</span>,MB_OK);
                    <span class="kwrd">if</span>(pError == NULL)
                        pError-&gt;Release();
                    m_inputFile.SetWindowText(NULL);
                    <span class="rem">//OnBnClickedCreateXml();</span>
                    <span class="kwrd">break</span>;
            }
        }    <span class="rem">// end catch(int errThrow)</span>
        <span class="kwrd">catch</span>(<span class="kwrd">const</span> <span class="kwrd">char</span>* str)
        {
            status = <span class="str">"Error............."</span>;
            m_status.SetWindowText(status);
            em.MessageBox(str,<span class="str">""</span>,MB_OK);
            m_inputFile.SetWindowText(NULL);
            GetDlgItem(IDC_DATA_SOURCE_FILE)-&gt;EnableWindow(TRUE);
            m_createXML.EnableWindow(TRUE);
            <span class="kwrd">break</span>;
        }    <span class="rem">// end catch(const char* str)</span>
        <span class="kwrd">catch</span>(_com_error &amp;e)
        {
            status = <span class="str">"Error............."</span>;
            m_status.SetWindowText(status);
            <span class="kwrd">const</span> <span class="kwrd">char</span> * err;
            err = e.ErrorMessage();
            em.MessageBox(err,<span class="str">"COM ERROR IN CREATE XML"</span>,MB_OK);
            <span class="kwrd">break</span>;
        }
        <span class="kwrd">catch</span>(...)
        {
            status = <span class="str">"Error............."</span>;
            m_status.SetWindowText(status);
            em.MessageBox(<span class="str">"Unknown Error in Create XML :"</span>,<span class="str">""</span>,MB_OK);
            <span class="kwrd">break</span>;
        }
        status = <span class="str">""</span>;
        m_status.SetWindowText(status);
        <span class="kwrd">break</span>;
    <span class="kwrd">case</span> IDCANCEL:
        <span class="rem">// Do something</span>
        status = <span class="str">""</span>;
        m_status.SetWindowText(status);
        GetDlgItem(IDC_DATA_SOURCE_FILE)-&gt;EnableWindow(TRUE);
        m_createXML.EnableWindow(TRUE);

        <span class="kwrd">break</span>;
    <span class="kwrd">default</span>:
        <span class="rem">// do something</span>
        <span class="kwrd">break</span>;
    };    <span class="rem">// end switch        </span>
}    <span class="rem">// end void CTrackToolDlg::OnBnClickedCreateXml()</span>

<span class="kwrd">void</span> CTrackToolDlg::OnBnClickedStart()
{
    <span class="rem">// TODO: Add your control notification handler code here</span>

    GetDlgItem(IDC_START)-&gt;EnableWindow(FALSE);
    hr = S_OK;
    <span class="kwrd">try</span> 
    {
        
        m_createXML.EnableWindow(FALSE);
        m_appendFile.EnableWindow(FALSE);

        m_outputFile.GetWindowText(status);
        vName.SetString(status);
        hr = theVisio-&gt;DOMDocumentPtr-&gt;save(vName);
        <span class="kwrd">if</span>(hr == S_FALSE) <span class="kwrd">throw</span> <span class="str">"Failed to save document for output"</span>;

        
        <span class="rem">//////////////////////////////////////////////</span>
        <span class="rem">///// the function initializePtrsToBuildShape(vName) /////</span>
        <span class="rem">///// assigns the DOMNodePtr of CVisio class /////</span>
        <span class="rem">///// to the first Shape Element /////</span>
        <span class="rem">///// A tag element called Shape has been deliberately /////</span>
        <span class="rem">///// introduced in a input.vdx file bundled with the setup /////</span>
        <span class="rem">///// any changes to the input.vdx file will lead to erroneous errors  /////</span>
        <span class="rem">///// and program failure.......... /////</span>
        <span class="rem">///// in order to build the output.vdx file It has to /////</span>
        <span class="rem">///// have one Shape Element, according to the algorithm /////</span>
        <span class="rem">///// adopted......... other intuitive methods can be implemented /////</span>
        theVisio-&gt;initializePtrsToBuildShape(vName);

        
        <span class="rem">//////////////////////////</span>
        <span class="rem">/////////////////////////////</span>
        <span class="rem">///// the fillxmlShape() function creates a Shape structure</span>
        <span class="rem">///// for visio..... it helps to pass the list. </span>
        <span class="rem">///// the BuildShape function looks for elements </span>
        <span class="rem">///// based on the list supplied................</span>
        <span class="rem">///// It was the solution on hand at that time</span>
        <span class="rem">///// a more intuitive approach will be later adopted</span>
        SUCCESS = theVisio-&gt;fillxmlShape();
        <span class="kwrd">if</span>(SUCCESS == VARIANT_FALSE) <span class="kwrd">throw</span> <span class="str">" Failed to fill Shape list "</span>;

        m_saveVisioFile = TRUE;
        fileInputTimer = SetTimer(1234,0,0);
    }    <span class="rem">// end try block</span>

    <span class="kwrd">catch</span>(<span class="kwrd">const</span> <span class="kwrd">char</span> *str)
    {
        em.MessageBox(str,<span class="str">""</span>,MB_OK);
        OnBnClickedCancelSourceFile();
    }
    <span class="kwrd">catch</span>(_com_error &amp;e)
    {
        <span class="kwrd">const</span> <span class="kwrd">char</span> * err;
        err = e.ErrorMessage();
        em.MessageBox(err,<span class="str">"COM ERROR IN START"</span>,MB_OK);
        
    }
    <span class="kwrd">catch</span>(...)
    {
        em.MessageBox(<span class="str">"Unknown Error"</span>,<span class="str">""</span>,MB_OK);
        OnBnClickedCancelSourceFile();
    }
    
}

<span class="kwrd">void</span> CTrackToolDlg::OnBnClickedAppend()
{
    <span class="rem">// TODO: Add your control notification handler code here</span>

    hr = S_OK;

    CFileDialog openDialog(TRUE, <span class="str">".*"</span>);
    openDialog.m_ofn.lpstrInitialDir = <span class="str">""</span>;
    openDialog.m_ofn.lpstrFilter = <span class="str">"All Files\0*.*\0\0"</span>;

    <span class="rem">// Return value when the File dialog box opens</span>
    INT_PTR nRet = -1;
    nRet = openDialog.DoModal();

    <span class="rem">// Handle the return value from DoModal</span>
    <span class="kwrd">switch</span> ( nRet )
    {
        <span class="kwrd">case</span> -1: 
            em.MessageBox(<span class="str">"Dialog Box could not be created !"</span>,<span class="str">""</span>,MB_OK);
            <span class="kwrd">break</span>;
        <span class="kwrd">case</span> IDABORT:
            <span class="rem">// Do something</span>
        
            em.MessageBox(<span class="str">"problem opening file, cause:"</span>, <span class="str">"file may not exist\n Close and Retry"</span>, MB_OK);
            exit(0);
            <span class="kwrd">break</span>;
        <span class="kwrd">case</span> IDOK:
        <span class="rem">// Do something</span>
            <span class="kwrd">try</span>
            {
                hr = S_OK;
                <span class="kwrd">int</span> errThrow = 0;
                status = openDialog.GetPathName();
                m_inputFile.SetWindowText(status);
                vName.Clear();
                m_inputFile.GetWindowText(status);
                vName.SetString(status);
        
                <span class="kwrd">if</span>(theVisio != NULL)
                {
                    theVisio = NULL;
                    delete theVisio;
                }

                theVisio = <span class="kwrd">new</span> CVisio();
                theVisio-&gt;DOMDocumentPtr-&gt;async = FALSE;
                theVisio-&gt;DOMDocumentPtr-&gt;validateOnParse = TRUE;
                hr = theVisio-&gt;DOMDocumentPtr-&gt;load(vName);
                <span class="kwrd">if</span>( hr == S_FALSE) <span class="kwrd">throw</span> 2;
                <span class="kwrd">if</span>(theVisio-&gt;DOMDocumentPtr-&gt;readyState != 4) {
                    <span class="kwrd">while</span>(theVisio-&gt;DOMDocumentPtr-&gt;readyState != 4) {
                    ::Sleep(1000);
                    }    <span class="rem">// end while</span>
                }    <span class="rem">// end if</span>

                <span class="rem">//theVisio-&gt;DOMNodeListPtr = theVisio-&gt;DOMDocumentPtr-&gt;getElementsByTagName("Shape");</span>
                theVisio-&gt;DOMNodeListPtr = theVisio-&gt;DOMDocumentPtr-&gt;selectNodes(_bstr_t(<span class="str">"//Shape"</span>));

                <span class="rem">// it is important to know the num of Shape Elements in the visio file</span>
                <span class="rem">// the new shapes will be added from here.</span>
                index = theVisio-&gt;DOMNodeListPtr-&gt;Getlength();
                ++index;
        
                <span class="rem">// get the origins </span>
                <span class="rem">// get Origins of the Visio File</span>
                <span class="rem">//theVisio-&gt;DOMNodeListPtr = theVisio-&gt;DOMDocumentPtr-&gt;getElementsByTagName("XRulerOrigin");</span>
                theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMDocumentPtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Pages/Page/PageSheet/RulerGrid/XRulerOrigin"</span>));
                <span class="rem">//ASSERT(theVisio-&gt;DOMNodeListPtr != NULL);</span>
                <span class="rem">//if(theVisio-&gt;DOMNodeListPtr == NULL) throw " Please check the file you selected";</span>

                <span class="rem">//theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodeListPtr-&gt;item[1];</span>
                <span class="rem">//ASSERT(theVisio-&gt;DOMNodePtr != NULL);</span>
                <span class="kwrd">if</span>(theVisio-&gt;DOMNodePtr == NULL) <span class="kwrd">throw</span> <span class="str">" Have you Selected the correct file? "</span>;

                theVisio-&gt;vt.Clear();
                theVisio-&gt;vt = theVisio-&gt;DOMNodePtr-&gt;GetnodeTypedValue();

                m_visXOrigin = myabs(<span class="kwrd">double</span>(theVisio-&gt;vt)/VISIOFACTOR);

                <span class="rem">//theVisio-&gt;DOMNodeListPtr = theVisio-&gt;DOMDocumentPtr-&gt;getElementsByTagName("YRulerOrigin");</span>
                theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMDocumentPtr-&gt;selectSingleNode(_bstr_t(<span class="str">"//Pages/Page/PageSheet/RulerGrid/YRulerOrigin"</span>));
                <span class="rem">//ASSERT(theVisio-&gt;DOMNodeListPtr != NULL);</span>

                <span class="rem">//theVisio-&gt;DOMNodePtr = theVisio-&gt;DOMNodeListPtr-&gt;item[1];</span>
                ASSERT(theVisio-&gt;DOMNodePtr != NULL);

                theVisio-&gt;vt.Clear();
                theVisio-&gt;vt = theVisio-&gt;DOMNodePtr-&gt;GetnodeTypedValue();

                m_visYOrigin = myabs(<span class="kwrd">double</span>(theVisio-&gt;vt)/VISIOFACTOR);


                theMap-&gt;minEasting = m_visXOrigin;
                theMap-&gt;minNorthing = m_visYOrigin;
                xFactor = 0;
                yFactor = 0;
                <span class="rem">//////////////////////////////////////////////////////////////////</span>
        }    <span class="rem">// end try block</span>
        <span class="kwrd">catch</span>(<span class="kwrd">int</span> errThrow)
        {    
            <span class="kwrd">if</span>(errThrow == 1){
                AfxMessageBox(<span class="str">" Unable to load the file, May be it is not the correct file"</span>,MB_OK);
                <span class="rem">//OnBnClickedCreateXml();</span>
                <span class="kwrd">break</span>;
            }

            <span class="kwrd">if</span>(errThrow == 2) 
            {
                MSXML2::IXMLDOMParseErrorPtr  pError;
                pError = theVisio-&gt;DOMDocumentPtr-&gt;parseError;
                _bstr_t parseError =_bstr_t(<span class="str">"At line "</span>)+ _bstr_t(pError-&gt;Getline()) + _bstr_t(<span class="str">"\n"</span>)+ _bstr_t(pError-&gt;Getreason());
                em.MessageBox(parseError, <span class="str">"Check File again :  Load failed "</span>,MB_OK);
                <span class="kwrd">if</span>(pError == NULL)
                    pError-&gt;Release();
                m_inputFile.SetWindowText(NULL);
                <span class="rem">//OnBnClickedCreateXml();</span>
                <span class="kwrd">break</span>;
            }
        }
        <span class="kwrd">catch</span>(<span class="kwrd">const</span> <span class="kwrd">char</span>* str)
        {
            em.MessageBox(str,<span class="str">""</span>,MB_OK);
            m_inputFile.SetWindowText(NULL);
            m_outputFile.SetWindowText(NULL);
            GetDlgItem(IDC_START)-&gt;EnableWindow(FALSE);
            <span class="kwrd">break</span>;
        }
    
        <span class="kwrd">catch</span>(_com_error &amp;e)
        {
            <span class="kwrd">const</span> <span class="kwrd">char</span> * err;
            err = e.ErrorMessage();
            em.MessageBox(err,<span class="str">"COM ERROR IN APPEND"</span>,MB_OK);
            <span class="kwrd">break</span>;
        }
    
        <span class="kwrd">catch</span>(...)
        {
            em.MessageBox(<span class="str">"Unknown Error :"</span>,<span class="str">""</span>,MB_OK);
            <span class="kwrd">break</span>;
        }

        <span class="kwrd">break</span>;
    <span class="kwrd">case</span> IDCANCEL:
        <span class="rem">// Do something</span>
        <span class="rem">// m_inputFile.SetWindowText(NULL);</span>
        <span class="rem">//m_cancelDataInput.EnableWindow(TRUE);</span>
        <span class="rem">//m_createXML.EnableWindow(TRUE);</span>
       
       
        <span class="kwrd">break</span>;
    <span class="kwrd">default</span>:
        <span class="rem">// do something</span>
        <span class="kwrd">break</span>;
    };    <span class="rem">// end switch            </span>
}    <span class="rem">// end function</span>

<span class="kwrd">void</span> __cdecl newhandler(){
    AfxMessageBox(<span class="str">"New Handler called "</span>,MB_OK);
    <span class="kwrd">throw</span> bad_alloc();
    <span class="kwrd">return</span>;
}

<span class="rem">//////////////////// </span>
<span class="rem">//////// there is no need of this function</span>
<span class="kwrd">void</span> CTrackToolDlg::OnAshtechVsCMCBoard(){
    <span class="rem">// Logic to read the CMC data vs Ashtech data</span>
    <span class="rem">// the function returns void</span>

}    <span class="rem">// end of function</span>

<span class="rem">/////////////////////////////////////////////////////////</span>
<span class="rem">////////// Function lineFillAlgorithm</span>
<span class="rem">////////  This function is used to walk the line and fill in the remaining </span>
<span class="rem">//////// spaces adjacent to the line that are not filled and interpolated</span>
<span class="kwrd">void</span> CTrackToolDlg::lineFillAlgorithm(<span class="kwrd">double</span> Ax1,<span class="kwrd">double</span> Ay1,<span class="kwrd">double</span> Bx1,<span class="kwrd">double</span> By1,<span class="kwrd">double</span> A1,<span class="kwrd">double</span> B1,<span class="kwrd">double</span> C1,<span class="kwrd">double</span> D1)
{    
    <span class="rem">//CPaintDC dc(this);</span>
    <span class="rem">//pDC = GetDC();</span>
    <span class="rem">//RenderableCircle rcCurrent(pDC,RGB(255, 0, 0), (int) __max(2.0 , -4.0), RGB(0, 0, 0));</span>

    trackMapVals line;
    <span class="kwrd">double</span> Ax = abs(Ax1);
    <span class="kwrd">double</span> Ay = abs(Ay1);
    <span class="kwrd">double</span> Bx = abs(Bx1);
    <span class="kwrd">double</span> By = abs(By1);
    <span class="kwrd">double</span> A = A1;
    <span class="kwrd">double</span> B = B1;
    <span class="kwrd">double</span> C = C1;
    <span class="kwrd">double</span> D = D1;
    
    <span class="rem">//////////////////// /////////////////////////////////////</span>
    <span class="rem">//////////// Check and interpolate for Ax and Ay</span>
    <span class="kwrd">int</span> mx = floor(Ax) - floor(leastEasting) + 2;
    <span class="kwrd">int</span> my = floor(Ay) - floor(leastNorthing) + 2;

    line = trackGrid[my][mx];
    <span class="kwrd">if</span>(line.Filled == FALSE)
    {
        line.Altitude = (-D-(A*Ax)-(B*Ay))/C;
        <span class="kwrd">if</span>(line.Altitude &gt; 0)
        {
            line.InterPolated = TRUE;
            line.Filled = TRUE;
            trackGrid[my][mx] = line;
            <span class="rem">//rcCurrent.render(pDC,mx,my);</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
                            
        }
    }

    line = trackGrid[my][mx +1];
    <span class="kwrd">if</span>(line.Filled == FALSE)
    {
        line.Altitude = (-D-(A*(Ax + 1))-(B*Ay))/C;
        <span class="kwrd">if</span>(line.Altitude &gt; 0)
        {
            line.InterPolated = TRUE;
            line.Filled = TRUE;
            trackGrid[my][mx + 1] = line;
            <span class="rem">//rcCurrent.render(pDC,mx,my);</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
            
        }
    }

    line = trackGrid[my + 1][mx];
    <span class="kwrd">if</span>(line.Filled == FALSE)
    {
        line.Altitude = (-D-(A*Ax)-(B*(Ay + 1)))/C;
        <span class="kwrd">if</span>(line.Altitude &gt; 0)
        {
            line.InterPolated = TRUE;
            line.Filled = TRUE;
            trackGrid[my + 1][mx] = line;
            <span class="rem">//rcCurrent.render(pDC,mx,my);</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
        }
    }

    line = trackGrid[my + 1][mx + 1];
    <span class="kwrd">if</span>(line.Filled == FALSE)
    {
        line.Altitude = (-D-(A*(Ax + 1))-(B*(Ay + 1)))/C;
        <span class="kwrd">if</span>(line.Altitude &gt; 0)
        {
            line.InterPolated = TRUE;
            line.Filled = TRUE;
            trackGrid[my + 1][mx + 1] = line;
            <span class="rem">//rcCurrent.render(pDC,mx,my);</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
            
        }
    }

    <span class="rem">//////////////////// /////////////////////////////////////</span>
    <span class="rem">//////////// Check and interpolate for Bx and By</span>
    mx = floor(Bx) - floor(leastEasting) + 2;
    my = floor(By) - floor(leastNorthing) + 2;

    line = trackGrid[my][mx];
    <span class="kwrd">if</span>(line.Filled == FALSE)
    {
        line.Altitude = (-D-(A*Bx)-(B*By))/C;
        <span class="kwrd">if</span>(line.Altitude &gt; 0)
        {
            line.InterPolated = TRUE;
            line.Filled = TRUE;
            trackGrid[my][mx] = line;
            <span class="rem">//rcCurrent.render(pDC,mx,my);</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
            
        }
    }

    line = trackGrid[my][mx +1];
    <span class="kwrd">if</span>(line.Filled == FALSE)
    {
        line.Altitude = (-D-(A*(Bx + 1))-(B*By))/C;
        <span class="kwrd">if</span>(line.Altitude &gt; 0)
        {
            line.InterPolated = TRUE;
            line.Filled = TRUE;
            trackGrid[my][mx + 1] = line;
            <span class="rem">//rcCurrent.render(pDC,mx,my);</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
            
        }
    }

    line = trackGrid[my + 1][mx];
    <span class="kwrd">if</span>(line.Filled == FALSE)
    {
        line.Altitude = (-D-(A*Bx)-(B*(By + 1)))/C;
        <span class="kwrd">if</span>(line.Altitude &gt; 0)
        {
            line.InterPolated = TRUE;
            line.Filled = TRUE;
            trackGrid[my + 1][mx] = line;
            <span class="rem">//rcCurrent.render(pDC,mx,my);</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
            
        }
    }

    line = trackGrid[my + 1][mx + 1];
    <span class="kwrd">if</span>(line.Filled == FALSE)
    {
        line.Altitude = (-D-(A*(Bx + 1))-(B*(By + 1)))/C;
        <span class="kwrd">if</span>(line.Altitude &gt; 0)
        {
            line.InterPolated = TRUE;
            line.Filled = TRUE;
            trackGrid[my + 1][mx + 1] = line;
            <span class="rem">//rcCurrent.render(pDC,mx,my);</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
            
        }
    }

    <span class="rem">//////////////////////////////////////////////////////////////////</span>
    <span class="rem">//////////// Bresenham's line drawing algorithm</span>
    <span class="rem">//////////// For every point that we intercept , we go two spaces in</span>
    <span class="rem">///////////  4 directions and interpolate the altitude/////////////</span>
    <span class="rem">//////////// This is just to make sure we hit all the points in the track</span>
    <span class="rem">////////////////////////</span>

    <span class="rem">//------------------------------------------------------------------------</span>
    <span class="rem">// INITIALIZE THE COMPONENTS OF THE ALGORITHM THAT ARE NOT AFFECTED BY THE</span>
    <span class="rem">// SLOPE OR DIRECTION OF THE LINE</span>
    <span class="rem">//------------------------------------------------------------------------</span>
    <span class="kwrd">int</span> dX = abs(Bx-Ax);    <span class="rem">// store the change in X and Y of the line endpoints</span>
    <span class="kwrd">int</span> dY = abs(By-Ay);

    <span class="rem">//------------------------------------------------------------------------</span>
    <span class="rem">// DETERMINE "DIRECTIONS" TO INCREMENT X AND Y (REGARDLESS OF DECISION)</span>
    <span class="rem">//------------------------------------------------------------------------</span>
    <span class="kwrd">int</span> Xincr, Yincr;
    <span class="kwrd">if</span> (Ax &gt; Bx) { Xincr=-1; } <span class="kwrd">else</span> { Xincr=1; }    <span class="rem">// which direction in X?</span>
    <span class="kwrd">if</span> (Ay &gt; By) { Yincr=-1; } <span class="kwrd">else</span> { Yincr=1; }    <span class="rem">// which direction in Y?</span>

    <span class="rem">//------------------------------------------------------------------------</span>
    <span class="rem">// BOOLEAN VARIABLE TO CHECK FOR EXTENTS</span>
    <span class="rem">//------------------------------------------------------------------------</span>
    BOOL EXTENTS = FALSE;
    <span class="rem">//------------------------------------------------------------------------</span>
    <span class="rem">// DETERMINE INDEPENDENT VARIABLE (ONE THAT ALWAYS INCREMENTS BY 1 (OR -1) )</span>
    <span class="rem">// AND INITIATE APPROPRIATE LINE DRAWING ROUTINE (BASED ON FIRST OCTANT</span>
    <span class="rem">// ALWAYS). THE X AND Y'S MAY BE FLIPPED IF Y IS THE INDEPENDENT VARIABLE.</span>
    <span class="rem">//------------------------------------------------------------------------</span>
    <span class="kwrd">if</span> (dX &gt;= dY)    <span class="rem">// if X is the independent variable</span>
    {
        <span class="kwrd">int</span> dPr     = dY&lt;&lt;1;           <span class="rem">// amount to increment decision if right is chosen (always)</span>
        <span class="kwrd">int</span> dPru     = dPr - (dX&lt;&lt;1);   <span class="rem">// amount to increment decision if up is chosen</span>
        <span class="kwrd">int</span> P         = dPr - dX;  <span class="rem">// decision variable start value</span>

        <span class="kwrd">for</span> (; dX &gt;= 0; dX--)            <span class="rem">// process each point in the line one at a time (just use dX)</span>
        {
            <span class="rem">//EXTENTS = checkExtents(Ax,Ay);</span>
            <span class="rem">//if(EXTENTS == TRUE)</span>
                pointFillAlgorithm(Ax, Ay, A,B,C,D); <span class="rem">// plot the pixel</span>
            <span class="rem">//EXTENTS = FALSE;</span>
            <span class="kwrd">if</span> (P &gt; 0)               <span class="rem">// is the pixel going right AND up?</span>
            {
                Ax+=Xincr;           <span class="rem">// increment independent variable</span>
                Ay+=Yincr;         <span class="rem">// increment dependent variable</span>
                P+=dPru;           <span class="rem">// increment decision (for up)</span>
            }
            <span class="kwrd">else</span>                     <span class="rem">// is the pixel just going right?</span>
            {
                Ax+=Xincr;         <span class="rem">// increment independent variable</span>
                P+=dPr;            <span class="rem">// increment decision (for right)</span>
            }
        }
    }
    <span class="kwrd">else</span>              <span class="rem">// if Y is the independent variable</span>
    {
        <span class="kwrd">int</span> dPr     = dX&lt;&lt;1;           <span class="rem">// amount to increment decision if right is chosen (always)</span>
        <span class="kwrd">int</span> dPru     = dPr - (dY&lt;&lt;1);   <span class="rem">// amount to increment decision if up is chosen</span>
        <span class="kwrd">int</span> P         = dPr - dY;  <span class="rem">// decision variable start value</span>

        <span class="kwrd">for</span> (; dY &gt;= 0; dY--)            <span class="rem">// process each point in the line one at a time (just use dY)</span>
        {
            <span class="rem">//EXTENTS = checkExtents(Ax,Ay);</span>
            <span class="rem">//if(EXTENTS == TRUE)</span>
                pointFillAlgorithm(Ax, Ay, A,B,C,D); <span class="rem">// plot the pixel</span>
            <span class="rem">//EXTENTS = FALSE;</span>
            <span class="kwrd">if</span> (P &gt; 0)               <span class="rem">// is the pixel going up AND right?</span>
            {
                Ax+=Xincr;         <span class="rem">// increment dependent variable</span>
                Ay+=Yincr;         <span class="rem">// increment independent variable</span>
                P+=dPru;           <span class="rem">// increment decision (for up)</span>
            }
            <span class="kwrd">else</span>                     <span class="rem">// is the pixel just going up?</span>
            {
                Ay+=Yincr;         <span class="rem">// increment independent variable</span>
                P+=dPr;            <span class="rem">// increment decision (for right)</span>
            }
        }
    }

<span class="rem">///////////////////////////////////////////</span>
<span class="rem">//////////////// ReleaseDC(pDC) helps clear the device context</span>
    <span class="rem">//if(pDC != NULL)</span>
        <span class="rem">//ReleaseDC(pDC);</span>

}    <span class="rem">// end function lineFillAlgorithm</span>

<span class="kwrd">void</span> CTrackToolDlg::pointFillAlgorithm(<span class="kwrd">double</span> Ax1,<span class="kwrd">double</span> Ay1,<span class="kwrd">double</span> A1,<span class="kwrd">double</span> B1,<span class="kwrd">double</span> C1,<span class="kwrd">double</span> D1)
{
    <span class="rem">//////////////////////////////////////////////////////////////////</span>
    <span class="rem">//////</span>
    <span class="rem">/// This function plots itself and two adjacent neighbours in all directions</span>
    <span class="rem">/////////////////////////</span>

    <span class="rem">//CPaintDC dc(this);</span>
    <span class="rem">//pDC = GetDC();</span>
    <span class="rem">//RenderableCircle rcCurrent(pDC,RGB(255, 0, 0), (int) __max(2.0 , -4.0), RGB(0, 0, 0));</span>

    trackMapVals point;
    <span class="kwrd">double</span> Ax = abs(Ax1);
    <span class="kwrd">double</span> Ay = abs(Ay1);
    <span class="kwrd">double</span> A = A1;
    <span class="kwrd">double</span> B = B1;
    <span class="kwrd">double</span> C = C1;
    <span class="kwrd">double</span> D = D1;

    <span class="rem">//////////////////// /////////////////////////////////////</span>
    <span class="rem">//////////// Check and interpolate for Ax and Ay</span>
    <span class="kwrd">int</span> mx = floor(Ax) - floor(leastEasting) + 2;
    <span class="kwrd">int</span> my = floor(Ay) - floor(leastNorthing) + 2;

    <span class="rem">//if( (mx &gt; 0) &amp;&amp; (my &gt; 0) &amp;&amp; (mx &lt; colMax) &amp;&amp; (my &lt; rowMax))</span>
    <span class="rem">//{</span>
    point = trackGrid[my][mx];
    <span class="kwrd">if</span>(point.Filled == FALSE)
    {
        point.Altitude = (-D-(A*Ax)-(B*Ay))/C;
        <span class="kwrd">if</span>(point.Altitude &gt; 0)
        {
            point.InterPolated = TRUE;
            point.Filled = TRUE;
            trackGrid[my][mx] = point;
            <span class="rem">//rcCurrent.render(pDC,mx,my);</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
        }
    }
    

    <span class="kwrd">for</span>(<span class="kwrd">int</span> incr = 1;incr &lt; 3;incr++)
    {
        point = trackGrid[my][mx + incr];
        <span class="kwrd">if</span>(point.Filled == FALSE)
        {
            point.Altitude = (-D-(A*(Ax + incr))-(B*Ay))/C;
            <span class="kwrd">if</span>(point.Altitude &gt; 0)
            {
                point.InterPolated = TRUE;
                point.Filled = TRUE;
                trackGrid[my][mx + incr] = point;
                <span class="rem">//rcCurrent.render(pDC,mx + incr,my);</span>
                <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
            }
        }

        point = trackGrid[my][mx - incr];
        <span class="kwrd">if</span>(point.Filled == FALSE)
        {
            point.Altitude = (-D-(A*(Ax - incr))-(B*Ay))/C;
            <span class="kwrd">if</span>(point.Altitude &gt; 0)
            {
                point.InterPolated = TRUE;
                point.Filled = TRUE;
                trackGrid[my][mx - incr] = point;
                <span class="rem">//rcCurrent.render(pDC,mx -incr,my);</span>
                <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
            }
        }

        point = trackGrid[my + incr][mx];
        <span class="kwrd">if</span>(point.Filled == FALSE)
        {
            point.Altitude = (-D-(A*Ax)-(B*(Ay + incr)))/C;
            <span class="kwrd">if</span>(point.Altitude &gt; 0)
            {
                point.InterPolated = TRUE;
                point.Filled = TRUE;
                trackGrid[my + incr][mx] = point;
                <span class="rem">//rcCurrent.render(pDC,mx,my + incr);</span>
                <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
            }
        }

        point = trackGrid[my - incr][mx];
        <span class="kwrd">if</span>(point.Filled == FALSE)
        {
            point.Altitude = (-D-(A*Ax)-(B*(Ay - incr)))/C;
            <span class="kwrd">if</span>(point.Altitude &gt; 0)
            {
                point.InterPolated = TRUE;
                point.Filled = TRUE;
                trackGrid[my - incr][mx] = point;
                <span class="rem">//rcCurrent.render(pDC,mx,my - incr);</span>
                <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
            }
        }

    }    <span class="rem">// end for(int incr = 1;incr &lt; 3;incr++)</span>
    <span class="rem">//}</span>
    <span class="rem">//if(pDC != NULL)</span>
        <span class="rem">//ReleaseDC(pDC);</span>
}<span class="rem">// end function</span>

BOOL CTrackToolDlg::checkExtents(<span class="kwrd">double</span> Ax1,<span class="kwrd">double</span> Ay1)
{
    <span class="kwrd">double</span> Ax = floor(Ax1);
    <span class="kwrd">double</span> Ay = floor(Ay1);

    <span class="kwrd">if</span>(Ax &lt; (leastEasting  - 2) )
        <span class="kwrd">return</span> FALSE;
    <span class="kwrd">else</span>
        <span class="kwrd">return</span> TRUE;

    <span class="kwrd">if</span>(Ax &gt; (highestEasting + 2))
        <span class="kwrd">return</span> FALSE;
    <span class="kwrd">else</span>
        <span class="kwrd">return</span> TRUE;

    <span class="kwrd">if</span>(Ay &lt; (leastNorthing - 2))
        <span class="kwrd">return</span> FALSE;
    <span class="kwrd">else</span>
        <span class="kwrd">return</span> TRUE;

    <span class="kwrd">if</span>(Ay &gt; (highestNorthing + 2))
        <span class="kwrd">return</span> FALSE;
    <span class="kwrd">else</span>
        <span class="kwrd">return</span> TRUE;

    
}    <span class="rem">// end function</span>

<span class="kwrd">void</span> CTrackToolDlg::modifiedlineFillAlgorithm(<span class="kwrd">double</span> Ax1,<span class="kwrd">double</span> Ay1,<span class="kwrd">double</span> Bx1,<span class="kwrd">double</span> By1,<span class="kwrd">double</span> A1,<span class="kwrd">double</span> B1,<span class="kwrd">double</span> C1,<span class="kwrd">double</span> D1)
{    
    CPaintDC dc(<span class="kwrd">this</span>);
    <span class="rem">//pDC = GetDC();;</span>
<span class="rem">//    RenderableCircle rcCurrent(pDC,RGB(255, 0, 0), (int) __max(2.0 , -4.0), RGB(0, 0, 0));</span>

    trackMapVals line;
    <span class="kwrd">double</span> Ax = abs(Ax1);
    <span class="kwrd">double</span> Ay = abs(Ay1);
    <span class="kwrd">double</span> Bx = abs(Bx1);
    <span class="kwrd">double</span> By = abs(By1);
    <span class="kwrd">double</span> A = A1;
    <span class="kwrd">double</span> B = B1;
    <span class="kwrd">double</span> C = C1;
    <span class="kwrd">double</span> D = D1;
    
    <span class="rem">//////////////////// /////////////////////////////////////</span>
    <span class="rem">//////////// Check and interpolate for Ax and Ay</span>
    <span class="kwrd">int</span> mx = Ax - floor(leastEasting) + 2;
    <span class="kwrd">int</span> my = Ay - floor(leastNorthing) + 2;

    line = trackGrid[my][mx];
    <span class="kwrd">if</span>(line.Filled == FALSE)
    {
        line.Altitude = (-D-(A*Ax)-(B*Ay))/C;
        <span class="kwrd">if</span>(line.Altitude &gt; 0)
        {
            line.InterPolated = TRUE;
            line.Filled = TRUE;
            trackGrid[my][mx] = line;
            <span class="rem">//rcCurrent.render(pDC,mx,my);</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
                            
        }
    }

    line = trackGrid[my][mx +1];
    <span class="kwrd">if</span>(line.Filled == FALSE)
    {
        line.Altitude = (-D-(A*(Ax + 1))-(B*Ay))/C;
        <span class="kwrd">if</span>(line.Altitude &gt; 0)
        {
            line.InterPolated = TRUE;
            line.Filled = TRUE;
            trackGrid[my][mx + 1] = line;
            <span class="rem">//rcCurrent.render(pDC,mx,my);</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
            
        }
    }

    line = trackGrid[my + 1][mx];
    <span class="kwrd">if</span>(line.Filled == FALSE)
    {
        line.Altitude = (-D-(A*Ax)-(B*(Ay + 1)))/C;
        <span class="kwrd">if</span>(line.Altitude &gt; 0)
        {
            line.InterPolated = TRUE;
            line.Filled = TRUE;
            trackGrid[my + 1][mx] = line;
            <span class="rem">//rcCurrent.render(pDC,mx,my);</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
        }
    }

    line = trackGrid[my + 1][mx + 1];
    <span class="kwrd">if</span>(line.Filled == FALSE)
    {
        line.Altitude = (-D-(A*(Ax + 1))-(B*(Ay + 1)))/C;
        <span class="kwrd">if</span>(line.Altitude &gt; 0)
        {
            line.InterPolated = TRUE;
            line.Filled = TRUE;
            trackGrid[my + 1][mx + 1] = line;
            <span class="rem">//rcCurrent.render(pDC,mx,my);</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
            
        }
    }

    <span class="rem">//////////////////// /////////////////////////////////////</span>
    <span class="rem">//////////// Check and interpolate for Bx and By</span>
    mx = Bx - floor(leastEasting) + 2;
    my = By - floor(leastNorthing) + 2;

    line = trackGrid[my][mx];
    <span class="kwrd">if</span>(line.Filled == FALSE)
    {
        line.Altitude = (-D-(A*Bx)-(B*By))/C;
        <span class="kwrd">if</span>(line.Altitude &gt; 0)
        {
            line.InterPolated = TRUE;
            line.Filled = TRUE;
            trackGrid[my][mx] = line;
            <span class="rem">//rcCurrent.render(pDC,mx,my);</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
            
        }
    }

    line = trackGrid[my][mx +1];
    <span class="kwrd">if</span>(line.Filled == FALSE)
    {
        line.Altitude = (-D-(A*(Bx + 1))-(B*By))/C;
        <span class="kwrd">if</span>(line.Altitude &gt; 0)
        {
            line.InterPolated = TRUE;
            line.Filled = TRUE;
            trackGrid[my][mx + 1] = line;
            <span class="rem">//rcCurrent.render(pDC,mx,my);</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
            
        }
    }

    line = trackGrid[my + 1][mx];
    <span class="kwrd">if</span>(line.Filled == FALSE)
    {
        line.Altitude = (-D-(A*Bx)-(B*(By + 1)))/C;
        <span class="kwrd">if</span>(line.Altitude &gt; 0)
        {
            line.InterPolated = TRUE;
            line.Filled = TRUE;
            trackGrid[my + 1][mx] = line;
            <span class="rem">//rcCurrent.render(pDC,mx,my);</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
            
        }
    }

    line = trackGrid[my + 1][mx + 1];
    <span class="kwrd">if</span>(line.Filled == FALSE)
    {
        line.Altitude = (-D-(A*(Bx + 1))-(B*(By + 1)))/C;
        <span class="kwrd">if</span>(line.Altitude &gt; 0)
        {
            line.InterPolated = TRUE;
            line.Filled = TRUE;
            trackGrid[my + 1][mx + 1] = line;
            <span class="rem">//rcCurrent.render(pDC,mx,my);</span>
            <span class="rem">//dc.BitBlt(0,0,0,0,pDC,0,0,SRCCOPY);</span>
            
        }
    }

    <span class="rem">//////////////////////////////////////////////////////////////////</span>
    <span class="rem">//////////// Bresenham's modified line drawing algorithm</span>
    <span class="rem">//////////// For every point that we intercept , we go two spaces in</span>
    <span class="rem">///////////  4 directions and interpolate the altitude/////////////</span>
    <span class="rem">//////////// This is just to make sure we hit all the points in the track</span>
    <span class="rem">////////////////////////</span>

    <span class="kwrd">int</span> i;               <span class="rem">// loop counter </span>
    <span class="kwrd">int</span> ystep, xstep;    <span class="rem">// the step on y and x axis </span>
    <span class="kwrd">int</span> error;           <span class="rem">// the error accumulated during the increment </span>
    <span class="kwrd">int</span> errorprev;       <span class="rem">// *vision the previous value of the error variable </span>
    <span class="kwrd">int</span> y = Ay, x = Ax;  <span class="rem">// the line points </span>
    <span class="kwrd">int</span> ddy, ddx;        <span class="rem">// compulsory variables: the double values of dy and dx </span>
    <span class="kwrd">int</span> dx = Bx - Ax; 
    <span class="kwrd">int</span> dy = By - By; 
    BOOL EXTENTS = FALSE;

    EXTENTS = checkExtents(Ax,Ay);
    <span class="kwrd">if</span>(EXTENTS == TRUE)
        pointFillAlgorithm(x, y, A,B,C,D); <span class="rem">// plot the pixel</span>
    EXTENTS = FALSE;
    <span class="rem">//POINT (y1, x1);  // first point </span>
    <span class="rem">// NB the last point can't be here, because of its previous point (which has to be verified) </span>
    <span class="kwrd">if</span> (dy &lt; 0)
    { 
        ystep = -1; 
         dy = -dy; 
    }
    <span class="kwrd">else</span> 
        ystep = 1; 
    <span class="kwrd">if</span> (dx &lt; 0)
    { 
        xstep = -1; 
        dx = -dx; 
    }
    <span class="kwrd">else</span> 
        xstep = 1; 
    ddy = 2 * dy;  <span class="rem">// work with double values for full precision </span>
    ddx = 2 * dx; 
    <span class="kwrd">if</span> (ddx &gt;= ddy)
    {  
        <span class="rem">// first octant (0 &lt;= slope &lt;= 1) </span>
        <span class="rem">// compulsory initialization (even for errorprev, needed when dx==dy) </span>
        errorprev = error = dx;  <span class="rem">// start in the middle of the square </span>
        <span class="kwrd">for</span> (i=0 ; i &lt; dx ; i++)
        {  
            <span class="rem">// do not use the first point (already done) </span>
            x += xstep; 
            error += ddy; 
            <span class="kwrd">if</span> (error &gt; ddx)
            {  
                <span class="rem">// increment y if AFTER the middle ( &gt; ) </span>
                y += ystep; 
                 error -= ddx; 
                <span class="rem">// three cases (octant == right-&gt;right-top for directions below): </span>
                <span class="kwrd">if</span> (error + errorprev &lt; ddx)  <span class="rem">// bottom square also </span>
                    <span class="rem">//POINT (y-ystep, x);</span>
                    pointFillAlgorithm(x, y-ystep, A,B,C,D); <span class="rem">// plot the pixel</span>
                <span class="kwrd">if</span> (error + errorprev &gt; ddx)  <span class="rem">// left square also </span>
                    <span class="rem">//POINT (y, x-xstep); </span>
                    pointFillAlgorithm(x-xstep, y, A,B,C,D); <span class="rem">// plot the pixel</span>
                <span class="kwrd">else</span>
                <span class="rem">//{  // corner: bottom and left squares also </span>
                    <span class="rem">//POINT (y-ystep, x); </span>
                    <span class="rem">//POINT (y, x-xstep); </span>
                    pointFillAlgorithm(x-xstep, y-ystep, A,B,C,D); <span class="rem">// plot the pixel</span>
                    <span class="rem">//pointFillAlgorithm(x-step, y, A,B,C,D); // plot the pixel</span>
            }    <span class="rem">// end if </span>
        
            EXTENTS = checkExtents(x,y);
            <span class="kwrd">if</span>(EXTENTS == TRUE)
                pointFillAlgorithm(x, y, A,B,C,D); <span class="rem">// plot the pixel</span>
            EXTENTS = FALSE;
            errorprev = error; 
        }<span class="rem">// end for  </span>
    }    <span class="rem">// end if begin else</span>
    <span class="kwrd">else</span>
    {  <span class="rem">// the same as above </span>
        errorprev = error = dy; 
        <span class="kwrd">for</span> (i=0 ; i &lt; dy ; i++)
        { 
            y += ystep; 
            error += ddx; 
            <span class="kwrd">if</span> (error &gt; ddy)
            { 
                x += xstep; 
                error -= ddy; 
                <span class="kwrd">if</span> (error + errorprev &lt; ddy) 
                    <span class="rem">//POINT (y, x-xstep); </span>
                    pointFillAlgorithm(x-xstep, y, A,B,C,D); <span class="rem">// plot the pixel</span>
                <span class="kwrd">if</span> (error + errorprev &gt; ddy) 
                    <span class="rem">//POINT (y-ystep, x);</span>
                    pointFillAlgorithm(x, y-ystep, A,B,C,D); <span class="rem">// plot the pixel</span>
                <span class="kwrd">else</span>
                <span class="rem">//{ </span>
                    <span class="rem">//POINT (y, x-xstep); </span>
                    <span class="rem">//POINT (y-ystep, x); </span>
                    pointFillAlgorithm(x-xstep, y-ystep, A,B,C,D); <span class="rem">// plot the pixel</span>
                    <span class="rem">//pointFillAlgorithm(x, y, A,B,C,D); // plot the pixel</span>
            }<span class="rem">// end if </span>
             
            EXTENTS = checkExtents(x,y);
            <span class="kwrd">if</span>(EXTENTS == TRUE)
                pointFillAlgorithm(x, y, A,B,C,D); <span class="rem">// plot the pixel</span>
            EXTENTS = FALSE;
            errorprev = error; 
        }<span class="rem">// end for </span>
    
    }<span class="rem">// end else (ddx &gt;= ddy){</span>
    <span class="rem">//if(pDC != NULL)</span>
        <span class="rem">//ReleaseDC(pDC);</span>
}    <span class="rem">// end function</span>


<span class="kwrd">void</span> CTrackToolDlg::funcToInterpolateTrack(list&lt;trackMapVals&gt; &amp;trackList)
{
    <span class="rem">//trackMapVals track;</span>
    <span class="rem">//list&lt;trackMapVals&gt;::iterator trackListIter;</span>
    

    
    <span class="rem">//int listSize = trackList.size();</span>
    <span class="kwrd">double</span> *trackArrayofAltitudes;
    <span class="rem">//int counter = 0;</span>
    <span class="kwrd">try</span>
    {
        <span class="rem">//list&lt;trackMapVals&gt; tempTrack,temptempTrack;    // two lists for manipulating the list</span>
        <span class="rem">//list&lt;trackMapVals&gt;::iterator listTrackIter,tempIter,temptempIter;    // iterators to point to the list</span>
        <span class="rem">//trackMapVals listtrack;    // struct object to hold values</span>
        <span class="kwrd">static</span> <span class="kwrd">int</span> listcounter = 0;

        <span class="kwrd">if</span>(trackList.empty() == TRUE)
            <span class="kwrd">throw</span> <span class="str">" Track is empty please check "</span>;
        <span class="kwrd">if</span>(tempTrack.empty() == FALSE)
            tempTrack.clear();

        <span class="kwrd">if</span>(temptempTrack.empty() == FALSE)
            temptempTrack.clear();

        BOOL FINDER;
        FINDER = TRUE;
        <span class="rem">//initially check to see if list starts with a zero or nonzero value</span>
        listTrackIter = trackList.begin();
        listtrack = *listTrackIter;
        <span class="rem">// check if listtrack.Altitude == 0</span>
        
        <span class="kwrd">if</span>(listtrack.Altitude == 0)
        {
            <span class="rem">// enter the loop only if list starts with zero</span>
            <span class="rem">// the idea is to rearrange the list to start with a number</span>
            <span class="rem">// and to join the first number to the last of the list</span>

            <span class="kwrd">for</span>(listTrackIter = trackList.begin();listTrackIter != trackList.end();listTrackIter++)
            {
                listtrack = *listTrackIter;
                <span class="kwrd">if</span>((listtrack.Altitude == 0) &amp;&amp; (FINDER == TRUE))
                    tempTrack.push_back(*listTrackIter);
                
                <span class="kwrd">if</span>(listtrack.Altitude != 0.0)
                {        
                    <span class="kwrd">if</span>(FINDER == TRUE)
                    {
                        <span class="kwrd">if</span>(tempTrack.empty() == FALSE)
                            tempTrack.clear();    <span class="rem">// clear the track of previous zero altitude if any</span>
                        tempIter = listTrackIter;    <span class="rem">// assign the iterator </span>
                        <span class="kwrd">for</span>(;tempIter != trackList.end();tempIter++)
                        {
                            tempTrack.push_back(*tempIter);
                        }    <span class="rem">// end for(;tempIter != trackList.end();tempIter+)</span>

                        <span class="rem">// assign the iterator again to point to the original list</span>
                        tempIter = listTrackIter;

                        <span class="kwrd">while</span>(tempIter != trackList.begin())
                        {
                            listcounter++;
                            tempIter--;
                        }    <span class="rem">// end while(tempIter != trackList.begin())</span>

                        <span class="rem">// assign the iterator to beginning of list</span>
                        tempIter = trackList.begin();

                        <span class="kwrd">for</span>(<span class="kwrd">int</span> k = 0; k &lt; listcounter; k++)
                        {
                            tempTrack.push_back(*tempIter);
                            tempIter++;
                        }    <span class="rem">// end for(int k = 0; k &lt; listcounter; k++)</span>

                        FINDER = FALSE;
                    }    <span class="rem">// end if(FINDER)</span>
                }    <span class="rem">// end if(listtrack.Altitude != 0)</span>
            }    <span class="rem">// end for(listTrackIter = trackList.begin();listTrackIter != trackList.end();listTrackIter++)</span>

            <span class="rem">// clear the original list and assign the nodes from </span>
            <span class="rem">// the templist</span>
            <span class="rem">//if(trackList.empty() ==  FALSE)</span>
                trackList.clear();

                <span class="kwrd">for</span>(listTrackIter = tempTrack.begin();listTrackIter != tempTrack.end();listTrackIter++)
                    trackList.push_back(*listTrackIter);
        }    <span class="rem">// end if(listtrack.Altitude == 0)</span>

        <span class="rem">// join the first point to the last </span>
        listTrackIter = trackList.begin();
        trackList.push_back(*listTrackIter);


        <span class="rem">// the list is now rearranged...................</span>
        <span class="rem">// i.e it starts with a non zero altitude and ends with a non zero altitude</span>
        <span class="rem">// or if all the elements are of altitude zero then it is as it is with an extra node</span>

        <span class="rem">// to interpolate the track based on the rearrangement</span>
        <span class="kwrd">double</span> firstItem,secondItem;
        firstItem = 0.0;
        secondItem = 0.0;
        <span class="kwrd">static</span> <span class="kwrd">int</span> listcount;
        listcount = 0;

        tempIter = trackList.begin();
        listtrack = *tempIter;
        firstItem = listtrack.Altitude;
        secondItem = listtrack.Altitude;
        
        <span class="rem">//if(tempTrack.empty() == FALSE)</span>
            tempTrack.clear();        <span class="rem">// clear the list</span>
            temptempTrack.clear();    <span class="rem">// clear the list</span>

        <span class="kwrd">for</span>(listTrackIter = trackList.begin();listTrackIter != trackList.end();listTrackIter++)
        {
            listtrack = *listTrackIter;
            <span class="kwrd">if</span>(listtrack.Altitude == 0)
                temptempTrack.push_back(*listTrackIter);

            <span class="kwrd">if</span>(listtrack.Altitude != 0)
            {
                <span class="kwrd">if</span>(temptempTrack.size() &gt; 0)
                    temptempIter = temptempTrack.begin();
                firstItem = secondItem;
                listtrack = *listTrackIter;
                secondItem = listtrack.Altitude;
                <span class="kwrd">double</span> difference = (firstItem - secondItem);

                <span class="kwrd">for</span>(<span class="kwrd">int</span> z = 1; z &lt; listcount; z++)
                {
                    <span class="kwrd">double</span> deltadiff;
                    <span class="rem">//if(difference != 0)</span>
                        deltadiff = -(difference/listcount);
                    <span class="rem">//else</span>
                        <span class="rem">//deltadiff = 0;</span>
                    firstItem = firstItem + deltadiff;
                    <span class="kwrd">if</span>(temptempIter != temptempTrack.end())
                        listtrack = *temptempIter;
                        
                    
                    listtrack.Altitude = firstItem;
                    tempTrack.push_back(listtrack);
                    ++temptempIter;

                }    <span class="rem">// end for(int z = 1; z &lt; listcount; z++)</span>

                tempTrack.push_back(*listTrackIter);
                <span class="rem">//if(!temptempTrack.empty() == FALSE)</span>
                    temptempTrack.clear();
                listcount = 0;
            }    <span class="rem">// end if(listtrack.Altitude != 0)</span>

            <span class="rem">// increment listcount</span>
            listcount++;

        }    <span class="rem">// end for(listTrackIter = trackList.begin();listTrackIter != trackList.end();listTrackIter++)</span>

        <span class="rem">// if all the elements are of altitude zero </span>
        <span class="rem">// temptempTrack contains the entire list</span>
        <span class="rem">// transfer the entire list to the main list</span>
        
        <span class="kwrd">if</span>(temptempTrack.size() == trackList.size())
        {
            trackList.clear();
            <span class="kwrd">for</span>(tempIter = temptempTrack.begin();tempIter != temptempTrack.end();tempIter++)
                trackList.push_back(*tempIter);

        }    <span class="rem">// end if(temptempTrack.size() == trackList.size())</span>
        
        
        <span class="rem">// if there are non zero elements</span>
        <span class="rem">// transfer the elements back to the list</span>
        <span class="kwrd">if</span>(temptempTrack.size() != trackList.size())
        {
            trackList.clear();
            <span class="kwrd">for</span>(tempIter = tempTrack.begin();tempIter != tempTrack.end();tempIter++)
                trackList.push_back(*tempIter);

        }

        <span class="rem">// clear tempTrack and temptempTrack;</span>
        tempTrack.clear();
        temptempTrack.clear();
        
        <span class="rem">/*</span>
<span class="rem">        // clear contents of tempTrack</span>
<span class="rem">        if(!tempTrack.empty())</span>
<span class="rem">                tempTrack.clear();</span>
<span class="rem">        //// </span>
<span class="rem">        // malloc an array of doubles to store the altitude in the same order</span>
<span class="rem">        /// as it is in the list</span>
<span class="rem">        ///</span>
<span class="rem"></span>
<span class="rem">        if((trackArrayofAltitudes = (double *)malloc(listSize* sizeof(double))) == NULL)</span>
<span class="rem">            throw " Insufficient Memory for allocation in funcToInterpolateTrack(..) ";</span>
<span class="rem">        for(listTrackIter = trackList.begin();listTrackIter != trackList.end();listTrackIter++)</span>
<span class="rem">        {    </span>
<span class="rem">            track = *listTrackIter;</span>
<span class="rem">            trackArrayofAltitudes[counter] = track.Altitude;</span>
<span class="rem">            ++counter;</span>
<span class="rem">        }// end for(listTrackIter = trackList.begin();listTrackIter != trackList.end();listTrackIter++)</span>
<span class="rem">        ///////////////////////////////////////</span>
<span class="rem">        ////////////////</span>
<span class="rem">        /// logic to interpolate the array and then store the values back to the list</span>
<span class="rem">        assignedPoints altPoints;</span>
<span class="rem">        for(int i = 0; i &lt; listSize; i++)</span>
<span class="rem">        {</span>
<span class="rem">            if(trackArrayofAltitudes[i] != 0.00)</span>
<span class="rem">            {</span>
<span class="rem">                altPoints.altitudeNumberInList = i;</span>
<span class="rem">                altPoints.altitudeValue = trackArrayofAltitudes[i];</span>
<span class="rem">                assignedPointsList.push_back(altPoints);</span>
<span class="rem">            }    // end if(trackArrayofAltitudes[i] != 0.00)</span>
<span class="rem">        }    // end for (int i = 0; i &lt; listSize; i++)</span>
<span class="rem"></span>
<span class="rem">        if(assignedPointsList.size() &gt; 1)    // to make sure more than one point had an assigned</span>
<span class="rem">                                            // altitude</span>
<span class="rem">        {</span>
<span class="rem">            assignedPoints firstAssignedPoint,secondAssignedPoint;</span>
<span class="rem">            assignedPointsListIter = assignedPointsList.begin();</span>
<span class="rem">            while(assignedPointsListIter != assignedPointsList.end())</span>
<span class="rem">            {</span>
<span class="rem">                </span>
<span class="rem">                firstAssignedPoint = *assignedPointsListIter;</span>
<span class="rem">                ++assignedPointsListIter;</span>
<span class="rem"></span>
<span class="rem">                if(assignedPointsListIter != assignedPointsList.end())</span>
<span class="rem">                    secondAssignedPoint = *assignedPointsListIter;</span>
<span class="rem"></span>
<span class="rem">                double altDifference;</span>
<span class="rem"></span>
<span class="rem">                altDifference = (firstAssignedPoint.altitudeValue - secondAssignedPoint.altitudeValue)/(firstAssignedPoint.altitudeNumberInList - secondAssignedPoint.altitudeNumberInList);</span>
<span class="rem">                for(int newVal = (firstAssignedPoint.altitudeNumberInList + 1); newVal &lt; secondAssignedPoint.altitudeNumberInList; newVal++)</span>
<span class="rem">                    trackArrayofAltitudes[newVal] = (trackArrayofAltitudes[newVal - 1] + altDifference);</span>
<span class="rem">                </span>
<span class="rem">            }//end while(assignedPointsListIter != assignedPointsList.end())</span>
<span class="rem"></span>
<span class="rem">            //////////////////////////////////////////////////////</span>
<span class="rem">            /////////////////////////////////////////////////////</span>
<span class="rem">            // Here the idea is to take the first point and the last point in</span>
<span class="rem">            // the list and interpolate between those point.......</span>
<span class="rem">            //// needs a little thinking</span>
<span class="rem">            assignedPointsListIter = assignedPointsList.begin();</span>
<span class="rem">            firstAssignedPoint = *assignedPointsListIter;</span>
<span class="rem">            assignedPointsListIter = assignedPointsList.end();</span>
<span class="rem">            --assignedPointsListIter;</span>
<span class="rem">            secondAssignedPoint = *assignedPointsListIter;</span>
<span class="rem">            double diff;</span>
<span class="rem">            diff = -((secondAssignedPoint.altitudeValue - firstAssignedPoint.altitudeValue)/(listSize - secondAssignedPoint.altitudeNumberInList + firstAssignedPoint.altitudeNumberInList));</span>
<span class="rem">            /////// fill the points from last point in list to end of list first</span>
<span class="rem">            /////// and then lets fill from the first item in list till beginning</span>
<span class="rem"></span>
<span class="rem">            for(int newValue = secondAssignedPoint.altitudeNumberInList + 1;newValue &lt; (listSize -1);newValue++)</span>
<span class="rem">                trackArrayofAltitudes[newValue] = (trackArrayofAltitudes[newValue - 1] + diff);</span>
<span class="rem"></span>
<span class="rem">            for(int newValueAgain = 0;newValueAgain &lt; firstAssignedPoint.altitudeNumberInList; newValueAgain++)</span>
<span class="rem">                trackArrayofAltitudes[newValueAgain] = (trackArrayofAltitudes[newValueAgain] + diff);</span>
<span class="rem"></span>
<span class="rem">            if(!OutCheckedList.empty())</span>
<span class="rem">                OutCheckedList.clear();</span>
<span class="rem">            counter = 0;</span>
<span class="rem">            for(trackListIter = trackList.begin();trackListIter != trackList.end();trackListIter++)</span>
<span class="rem">            {    </span>
<span class="rem">                track = *trackListIter;</span>
<span class="rem">                track.Altitude = trackArrayofAltitudes[counter];</span>
<span class="rem">                ++counter;</span>
<span class="rem">                OutCheckedList.push_back(track);</span>
<span class="rem">        }// end for(trackListIter = trackList.begin();trackListIter != trackList.end();trackListIter++)</span>
<span class="rem">        </span>
<span class="rem">            </span>
<span class="rem"></span>
<span class="rem">        }    // end if(assignedPointsList.size() &gt; 1)</span>
<span class="rem">        free(trackArrayofAltitudes);</span>
<span class="rem">        */</span>
    }    <span class="rem">// end try block</span>

    <span class="kwrd">catch</span>(<span class="kwrd">const</span> <span class="kwrd">char</span>* str)
    {
        em.MessageBox(str,<span class="str">""</span>,MB_OK);
        <span class="rem">/////////// Free the allocated memory rowwise</span>
        <span class="kwrd">for</span>(<span class="kwrd">int</span> freeMe = 0;freeMe &lt; rowMax;freeMe++)
        {
            <span class="kwrd">if</span>(trackGrid != NULL)
                free(trackGrid[freeMe]);
        }

        <span class="rem">/// finally free the array of pointers.</span>
        <span class="kwrd">if</span>(trackGrid != NULL) free(trackGrid);
        <span class="rem">//if(pDC != NULL)</span>
            <span class="rem">//ReleaseDC(pDC);</span>
        <span class="kwrd">if</span>(trackArrayofAltitudes != NULL)
            free(trackArrayofAltitudes);
    }<span class="rem">// end catch(const char* str)</span>
        <span class="kwrd">catch</span>(...)
        {
            em.MessageBox(<span class="str">"Unknown Error in Create XML :"</span>,<span class="str">""</span>,MB_OK);
            <span class="rem">/////////// Free the allocated memory rowwise</span>
            <span class="kwrd">for</span>(<span class="kwrd">int</span> freeMe = 0;freeMe &lt; rowMax;freeMe++)
            {
                <span class="kwrd">if</span>(trackGrid != NULL)
                    free(trackGrid[freeMe]);
            }

            <span class="rem">/// finally free the array of pointers.</span>
            <span class="kwrd">if</span>(trackGrid != NULL) free(trackGrid);
            <span class="rem">//if(pDC != NULL)</span>
                <span class="rem">//ReleaseDC(pDC);</span>
            <span class="kwrd">if</span>(trackArrayofAltitudes != NULL)
                free(trackArrayofAltitudes);
        }<span class="rem">// end catch(...)</span>
    
}<span class="rem">// end func</span>



<span class="rem">// function to get closest point</span>
<span class="kwrd">void</span> CTrackToolDlg::getClosestPoint(list&lt;trackMapVals&gt; &amp;trackList,trackMapVals referencePoint,trackMapVals &amp;closestPoint)
{

    
    <span class="rem">// try block</span>
    <span class="kwrd">try</span>
    {
        <span class="kwrd">double</span> angle,range,prevangle,prevrange;
        BOOL FOUND;
        FOUND = FALSE;
        UTMPosition UTMPositionRef(0,referencePoint.Northing,referencePoint.Easting);
        curListIter = trackList.begin();
        cur = *curListIter;
        UTMPosition UTMPositionClosest(0,cur.Northing,cur.Easting);

        UTMPositionRef.angleTo(UTMPositionClosest,prevangle,prevrange);

        <span class="kwrd">while</span>(curListIter != trackList.end())
        {
            ++curListIter;

            cur = *curListIter;
            UTMPosition UTMPositionNextClosest(0,cur.Northing,cur.Easting);
            UTMPositionRef.angleTo(UTMPositionNextClosest,angle,range);

            <span class="kwrd">if</span>(prevrange &gt; range)
            {
                prevrange = range;
                tmpListIter = curListIter;
                FOUND = TRUE;
            }<span class="rem">// end if(prevrange &gt; range)</span>


        }<span class="rem">// end while(curListIter != trackList.end())</span>

        <span class="kwrd">if</span>(!FOUND)
        {
            tmpListIter = trackList.begin();
            closestPoint = *tmpListIter;
        }<span class="rem">// end if(!FOUND)</span>

        <span class="kwrd">if</span>(FOUND)
        {
            closestPoint = *tmpListIter;
            FOUND = FALSE;
        }<span class="rem">// end if(FOUND)</span>

    }    <span class="rem">// end try block</span>

    <span class="kwrd">catch</span>(<span class="kwrd">const</span> <span class="kwrd">char</span> *str)
    {
        em.MessageBox(str,<span class="str">""</span>,MB_OK);
    }    <span class="rem">// end catch(const char *str)</span>
    <span class="kwrd">catch</span>(...)
    {
        em.MessageBox(<span class="str">"UnKnown Error in function getClosestPoint(......)"</span>,<span class="str">""</span>,MB_OK);
    }<span class="rem">// end catch(...)</span>

}<span class="rem">// end function trackMapVals&amp; CTrackToolDlg::getClosestPoint(list&lt;trackMapVals&gt; &amp;trackList,trackMapVals referencePoint)</span>
                    </pre></div> <!-- OISCSFileSection-->

                <div class="OISHTMLPageFooter">
        </div>
    </main>

    <footer id="main-footer">
        Copyright &copy; 2020
    </footer>

    <script src="js/main.js"></script>
</body>
</html